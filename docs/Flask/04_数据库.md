# 前言

数据库是绝大多数动态web程序的基础设置，只要你想把数据存储下来，就离不开数据库。数据库（Database）指的是由存储数据的单个或多个文件组成的集合，它是一种容器，可以类比为文件柜。而大家通常使用数据库来表示操作数据库的软件，这类管理数据库的软件被称为数据库管理系统（DBMS，Database Management System），常见的DBMS有MySQL、PostgreSQL、SQLite、MongoDB等。

为了便于理解，我们可以把数据库看做大仓库，仓库里有一些负责搬运货物（数据）的机器人，而DBMS就是操控机器人搬运货物的程序。



# 数据库分类

数据库一般分为两种，**SQL(Structured Query Language，结构性查询语言)数据库和NoSQL(Not Only SQL， 泛指非关系型)数据库。**

#### SQL

SQL数据库指关系型数据库，常用的SQL DBMS主要包括SQL Server、Oracle、MySQL、PostgreSQL、SQLite等。关系型数据库使用表来定义数据对象，不同的表之间使用关系连接。

在SQL数据库中，每一行代表一条记录(record)，每条记录又由不同的列(column)组成，在存储数据前，需要预先定义表模式(schema)，以定义表的结构并限定列的输入数据类型。

SQL数据库的几个基本概念如下：

- 表(table)：存储数据的特定结构。

- 模式(schema)：定义表的结构信息。

- 列/字段(column/field)： 表中的列，存储一系列特定的数据， 列组成表。

- 行/记录(row/record)：表中的行，代表一条记录。

- 标量(scalar)：指的是单一数据，与之相对的是集合 (collection)。

### NoSQL

NoSQL最初指No SQL或No Relational，现在NoSQL社区一般会解释为Not Only SQL。NoSQL数据泛指不使用传统关系型数据库中的表格形式的数据库。近年来，NoSQL数据库越来越流行，被大量应用在实时Web程序和大型程序中。与传统SQL数据库相比，它在速度和可扩展性方面有很大的优势，除此之外还拥有无模式(schema-free)、分布式、水平伸缩(horizontally scalable)等特点。

最常用的两种NoSQL数据库如下所示：

1. 文档存储（document store）

   文档存储是NoSQL数据库中最流行的种类，它可以作为主数据库使用。文档存储使用的文档类似SQL数据库中的记录，文档使用类JSON格式来表示数控。常见的文档存储DBMS有MongoDB、CouchDB等。

2. 键值对存储（key-value store）

   键值对存储在邢台上类似python中的字典，通过键来存储数据，在读取上非常快，通常用来存储临时内容，作为缓存使用。常见的键值对DBMS有Redis、Riak等，其中Redis不仅可以管理键值对数据库，还可以作为缓存后端（cache backend）和消息代理（message broker）。

另外还有列存储（column store， 又称为宽列式存储）、图式存储（graph store）等类型的NoSQL数据库。

### 如何选择

NoSQL数据库不需要定义表和列结构，也不限定存储的数据格式，在存储方式上比较灵活，在特定的场景下效率更高。

SQL数据库稍显复杂，但不容易出错，能够适应大部分的应用场景。

这两种数据库都各有优势，也各有擅长领域。两者并不是对立的，我们需要根据使用场景选择适合的数据库类型。大型项目通常会同时使用多种数据库，比如使用MySQL作为主数据库存储用户资料和文章，使用Redis缓存数据，使用MongoDB存储实时消息。



# ORM魔法

在Web应用里使用原生SQL语句操作数据库主要存在下面两类问题：

1. 手动编写SQL语句比较乏味，而且视图函数中加入太多SQL语句会降低代码的易读性。另外还会容易出现安全问题，如SQL注入等；
2. 常见的开发模式是在开发时使用简单的SQLite，而在部署时切换到MySQL等更健壮的DBMS。对于不同的DBMS，我们需要把使用不同的python接口库，这让DBMS的切换变得不太容易。

使用ORM可以很大程度上解决这些问题。它会自动帮你处理查询参数的转义，尽可能地避免SQL注入的发生。另外，它为不同的DBMS提供统一的接口，让切换工作变得非常简单。ORM扮演翻译的角色。能够将我们的python语言转换为DBMS能够读懂的SQL命令，让我们能够使用python来操控数据库。

ORM把底层的SQL数据实体转化为高层的python对象，这样一来，你甚至不需要了解SQL，只需要通过python代码即可完成数据库的操作，ORM主要实现了三层映射关系：

- 表 —> python类
- 字段(列) —> 类属性
- 记录(行) —> 类实例

除了便于使用，ORM还有下面这些有点：

1. 灵活性好。技能使用高层对象来操控数据库，又支持执行原生SQL语句；
2. 提升效率。从高层对象转换成原生SQL会牺牲一些性能，但这微不足道的性能牺牲换取的是巨大的效率提升；
3. 可移植性好。ORM通常支持多种DBMS，包括MySQL、PostgreSQL、Oracle、SQLite等，你可以随意更换DBMS，只需要改动少量配置。

使用python实现的ORM有SQLAlchemy、Peewee、PonyORM等，其中SQLAlchemy是python社区使用最广泛的ORM之一。



# 使用Flask-SQLAlchemy管理数据库

扩展Flask-SQLAlchemy集成了SQLAlchemy，它简化了连接数据库服务器、管理数据库操作会话等各类工作，让Flask中的数据处理体验变得更加轻松。

使用`pip install flask_sqlalchemy`安装完后，实例化Flask-SQLAlchemy提供的SQLAlchemy类，传入程序实例app，已完成扩展的初始化：

> 📢📢：同时需要安装psycopg2、psycopg2-binary这两个模块，否则会报错。

```python
from flask import Flask
from flask_sqlalchemy import SQLAlchemy

app = Flask(__name__)
db = SQLAlchemy(app)
```

我们将实例化扩展类的对象命名为db，这个db对象代表我们的数据库，它可以使用Flask-SQLAlchemy提供的所有功能。

> 虽然我们要使用的大部分类和函数都由SQLAlchemy提供，但在Flask-SQLAlchemy中，大多数情况下，我们 不需要手动从SQLAlchemy导入类或函数。在sqlalchemy和sqlalchemy.orm模块中实现的类和函数，以及其他几个常用的模块和对象都可以作为db对象的属性调用。当我们创建这样的调用时，Flask-SQLAlchemy会自动把这些调用转发到对应的类、函数或模块。

### 连接数据库服务器

DBMS通常会提供数据库服务器运行在操作系统中。要连接数据库服务器，首先要为我们的程序指定数据库URI（Uniform Resource Identifier，统一资源标识符）。数据库URI是一串包含各种属性的字符串，其中包含了各种用于连接数据库的信息。

常用的数据库URI格式如下：

| DBMS            | URI                                              |
| --------------- | ------------------------------------------------ |
| PostgreSQL      | postgresql://username:password@host/databasename |
| MySQL           | mysql://username:password@host/databasename      |
| Oracle          | oracle://username:password@host:prot/sidname     |
| SQLite(UNIX)    | sqlite:////absolute/path/to/foo.db               |
| SQLite(Windows) | sqlite:///absolute\\\path\\\to\\\foo.db          |
| SQLite(内存型)  | sqlite:///                                       |

> SQLite的数据库URI在Linux或macOS系统下的斜线数量是4个
>
> 在 Windows系统下的URI中的斜线数量为3个。内存型数据库的斜线固定为 3个

在Flask-SQLAlchemy中，数据库的URI通过配置变量SQLALCHEMY_DATABASE_URI设置，默认为SQLite内存型数据库。SQLite是基于文件的DBMS，不需要设置数据库服务器，只需要指定数据库文件的绝对路径。我们使用app.root_path来定位数据库文件的路径，并将数据库文件命名为data.db。

> SQLite数据库文件名不限定后缀，常用的命名方式有foo.sqlite、foo.db，或是注明SQLite版本的foo.sqlite3。

配置数据库URI的代码如下：

```python
app.config['SQLALCHEMY_DATABASE_URI'] = 'postgresql://zhengyaqi@localhost/db_demo'
```

设置好数据库URI后，在python shell中导入并查看db对象会获得下面的输出：

```shell
>>> from app import db
>>> db
<SQLAlchemy engine=postgresql://zhengyaqi@localhost/db_demo>
>>> 
```

安装并初始化Flask-SQLAlchemy后，启动程序时会看到命令行下有一行警告信息:

```shell
FSADeprecationWarning: SQLALCHEMY_TRACK_MODIFICATIONS adds significant overhead and will be disabled by default in the future.  Set it to True or False to suppress this warning.
```

这是因为Flask-SQLAlchemy建议你设置SQLALCHEMY_TRACK_MODIFICATIONS配置变量，这个配置变量决定是否追踪对象的修改，这用于Flask-SQLAlchemy的事件通知系统。这个配置键的默认值是None，如果没有特殊需要，我们可以把它设置为False来关闭警告信息:

```python
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
```



### 定义数据库模型

用来映射到数据库表的python类通常被称为数据库模型（model），一个数据库模型类对应数据库中的一个表。定义模型即使用python类定义表模式，并声明映射关系。所有的模型类都要继承Flask-SQLAlchemy提供的db.Model基类。

我们的示例程序是一个笔记程序，笔记保存到数据库中，你可以通过程序查询、添加、更新和删除笔记。

在模型类中，表的字段（列）有db.Column类的实例表示，字段的类型通过Column类构造方法的第一个参数传入，下面的代码中，我们构造了一个类型为db.Integer的id列和类型为db.Text的body列：

```python
from datetime import datetime

class Note(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    body = db.Column(db.Text)
    timestamp = db.Column(db.Datetime, default=datetime.now, index=True)
```

SQLAlchemy常用的字段类型如下：

| 字段        | 说明                                         |
| ----------- | -------------------------------------------- |
| Integer     | 整数                                         |
| String      | 字符串，可选参数length可以用来设置最大长度   |
| Text        | 较长的Unicode文本                            |
| Date        | 日期，存储python的datetime.date对象          |
| Time        | 时间，存储python的datetime.time对象          |
| DateTime    | 时间和日期，存储python的datetime对象         |
| Interval    | 时间间隔，存储python的datetime.timedelta对象 |
| Float       | 浮点数                                       |
| Boolean     | 布尔值                                       |
| PickleType  | 存储Pickle列化的python对象                   |
| LargeBinary | 存储任意二进制数据                           |

字段类型一般直接声明即可，如果需要传入参数，你也可以添加括号。对于类似String的字符串列，有些数据库会限定长度，因此最好为其指定长度，而Text类型可以存储相对灵活的变长文本，不需要指定长度。当你在数据库模型类中限制了字段的长度后，在接收对应数据的表单类字段里，也需要使用Length验证来验证用户的输入。

> 📢📢：
>
> timestamp字段的默认值是datetime.now而不是datetime.now()。前者是可调用的函数/方法对象(即名称)，而后者是函数/方法调用(即动作)。SQLAlchemy会在创建新的数据库记录时(即用户提交表单实例化Note类时)调用该对象来设置默认值，这也是我们期待的效果。如果传入的不是方法对象，那么这个方法在加载模块时就会被执行，这将不是正确的时间戳。

默认情况下，Flask-SQLAlchemy会根据模型类的名称生成一个表名称，规则如下：

- Message —> message：单个单词转换为小写
- FooBar —> foo_bar：多个单词转换为小写并使用下划线分隔

如果想自己指定表名称，可以通过定义`__tablename__`属性来实现。字段名默认为类属性名称，也可以通过字段类构造方法的第一个参数指定，或使用关键字参数`name`，常用的SQLAlchemy字段参数如下：

| 参数名      | 说明                                              |
| ----------- | ------------------------------------------------- |
| name        | 字段名称                                          |
| primary_key | 如果设置为True，该字段为主键                      |
| unique      | 如果设置为True，该字段不允许出现重复值            |
| index       | 如果设置为True，为该字段创建索引，以提高查询效率  |
| nullable    | 确定字段值是否可为空，值为True或False，默认为True |
| default     | 为字段设置默认值                                  |

### 创建数据库和表

创建模型类后，我们需要手动创建数据库和对应的表，也就是我们常说的建库和建表。这通过对我们的db对象调用create_all()方法实现：

```shell
>>> from app import db
>>> db.create_all()
```

可以通过下面的方式查看模型对应的SQL模式（建表语句）：

```shell
>>> from app import Note
>>> from sqlalchemy.schema import CreateTable
>>> print(CreateTable(Note.__table__))

CREATE TABLE note (
        id INTEGER NOT NULL, 
        body TEXT, 
        PRIMARY KEY (id)
)
```

> 数据库和表一旦创建后，之后对模型的改动不会自动作用到实际的表中。比如，在模型类中添加或删除字段，修改字段的名称和类型，这是再次调用create_all()也不会更新标结果。如果想使改动生效，最简单的方式就是调用db.drop_all()方法删除数据库和表，然后再调用db.create_all()方法创建。

我们也可以自己实现一个自定义的flask命令完成创建数据库和表的工作，代码如下：

```python
import click
...
@app.cli.command()
def initdb():
  db.create_all()
  click.echo('Initialized database.')
```

在命令行下输入flask initdb既可以创建数据库和表：

```shell
$ flask initdb
Initialized database.
```



# 数据库操作

数据库的主要操作是CRUD，即Create(创建)、Read(读取/查询)、Update(更新)、Delete(删除)。

SQLAlchemy使用数据库会话来管理数据库操作，这里的数据库会话也称为事务（transaction)。Flask-SQLAlchemy自动帮我们创建会话，可以通过`db.session`属性获取。

数据库中的会话代表一个临时存储区，你对数据库做出的改动都会存放在这里。你可以调用add()方法将新创建的对象添加到数据库会话中，或是对会话中的对象进行更新。只有当你对数据库会话对象调用commit()方法时，改动才会提交到数据库，这确保了数据提交的一致性。另外数据库会话也支持回滚操作。当你对会话调用rollback()方法时，添加到会话中且未提交的改动都将撤销。

### CRUD

默认情况下，Flask-SQLAlchemy会自动为模型生成一个`__repr__()`方法。当在python shell中调用模型对象时，`__repr__()`方法会返回一条类似`<模型类名主键值>`的字符串。为了方便实际测试，我们可以在模型类中重新定义`__repr__()`，返回一些有用的信息，如下：

```python
class Note(db.Model):
		...
    def __repr__(self):
        return '<Note %r>' % self.body
```

#### Create

添加一条新纪录到数据库主要分为三步：

1. 创建python对象（实例化模型类）作为一条记录；
2. 添加新创建的记录到数据库会话；
3. 提交数据库会话

```shell
>>> from app import app, db, Note
>>> note1 = Note(body='just do it.')
>>> note2 = Note(body="don't do that.")
>>> db.session.add(note1)
>>> db.session.add(note2)
>>> db.session.commit() 
```

除了调用add()方法添加多个记录，也可以使用add_all()方法一次添加包含所有记录对象的列表。

我们在创建模型类实例的时候并没有定义id字段的数据，这是因为主键由SQLAlchemy管理。模型类对象穿件后作为临时对象（transient），当你提交数据库会话后，模型类对象才会转换为数据库记录写入数据库中，这是模型类对象会自动获得id值。

```shell
>>> note1.id
1
```

#### Read

使用模型类提供的query属性附加调用各种过滤方法及查询方法可以从数据库里取回数据。

一般来说，一个完整的查询遵循下面的模式：

```shell
<模型类>.query.<过滤方法>.<查询方法>
```

从某个模型类触发，通过在query属性对应的Query对象上附加的过滤方法和查询函数对[模型类对应的表中的记录]进行筛选和调整，最终返回包含对应数据库记录的模型类实例，对返回的实例调用属性即可获取对应的字段数据。

##### 常用查询方法

SQLAlchemy提供了许多查询方法用来获取记录，常用的查询方法如下表：

| 查询方法              | 说明                                                         |
| --------------------- | ------------------------------------------------------------ |
| all()                 | 返回包含所有查询记录的列表                                   |
| first()               | 返回查询的第一条记录，如未找到，则返回None                   |
| one()                 | 返回第一条记录，且仅允许有一条记录，如果记录数量大于1或小于1，则抛出错误 |
| get(ident)            | 传入主键值作为参数，返回指定主键值的记录，如果未找到，则返回None |
| count()               | 返回查询结果的数量                                           |
| one_or_none()         | 类似one()，如果结果数量不为1，则返回None                     |
| first_or_404()        | 返回查询的第一条记录，如果未找到，则返回404错误响应          |
| get_or_404(ident)     | 传入主键值作为参数，返回指定主键值记录，如果未找到，则返回404错误响应 |
| paginate()            | 返回一个Paginate对象，可以对记录进行分页处理                 |
| with_parent(instance) | 传入模型实例作为参数，返回和这个实例相关联的对象             |

###### paginate() 分页

我们定义一个文章Post模型，在index()视图函数中查询出所有Post对象，并对其进行分页，在index.html模板中进行展示，视图函数如下：

```python
from flask import request, render_template
...
@app.route('/')
def index():
  page = requst.args.get('page', int, type=int)
  per_page = app.config['BLOG_PER_PAGE']
  pagination = Post.query.order_by(Post.created_at.desc()).paginate(page=page, per_page=per_page, error_out=False)
  posts = pagination.items
  
  return render_template('index.html', posts=posts, pagination=pagination)
```

我们用paginate()方法实现分页，它接收两个最主要的参数分别用来决定把记录分成几页（per_page），返回哪一页的记录（page）。page参数代表当前请求的页数，我们从请求的查询参数（request.args）中获取，如果没有设置则使用默认值1，指定int类型可以保证在参数类型错误时使用默认值；per_page参数设置每页返回的记录数量，为了方便同意修改，这个值从配置变量POST_PER_PAGE中获取。

另外，可以的error_out参数用于设置当前查询的页数超出总页数时的行为。当error_out设为True（默认值）时，如果页面超出最大值，page或per_page为复数或非整型数会返回404错误；如果设为False则返回空记录。

调用paginate()方法会返回一个Pagination类实例，它包含分页的信息，我们将其称为分页对象。对这个pagination对象调用items属性会以列表的形式返回指定页数（未指定为第一页）的记录。

> 如果没有指定page和per_page参数，Flask-SQLAlchemy会自动从查询字符串中获取对应的参数（page和per_page)的值，如果没有获取到，默认的page为1，per_page为20。
>
> 如在访问https://example.com/index?page=2&per_page=10这个URL时，将会获取到第二页的10条记录。

除了通过查询参数获取页数，还可以直接将页面作为URL的一部分，下面的视图函数就是将page作为URL变量：

```python
from flask import request, render_template
...
@app.route('/', defaults={'page': 1})
@app.route('/page/<int:page>')
def index(page):
  per_page = app.config['POST_PER_PAGE']
  pagination = Post.query.order_by(Post.created_at.desc()).paginate(page=page, per_page=per_page)
  posts = pagination.items
  return render_template('index.html', posts=posts, pagination=pagination)

```

##### 常用过滤方法

SQLAlchemy还提供了很多过滤方法，使用这些过滤方法可以获取更精确的查询，比如获取指定字段值的记录。对模型类的query属性存储的Query对象调用过滤方法将返回一个更精确的Query对象(简称查询对象)。因为每个过滤方法都会返回新的查询对象，所以过滤器可以叠加使用。在查询对象上调用前面说的查询方法，即可获得一个包含过滤后的记录列表。

常用的过滤方法如下：

| 查询过滤器名称 | 说明                                                         |
| -------------- | ------------------------------------------------------------ |
| filter()       | 使用指定的规则过滤记录，返回新产生的查询对象                 |
| filter_by()    | 使用指定规则过滤记录（以关键字表达式的形式），返回新产生的查询对象 |
| order_by()     | 根据指定条件对记录进行排序，返回新产生的查询对象             |
| limit(limit)   | 使用指定的值限制原查询返回的记录数量，返回新产生的查询对象   |
| group_by()     | 根据指定条件对记录进行分组，返回新产生的查询对象             |
| offset(offset) | 使用指定的值偏移原查询结果，返回新产生的查询对象             |

filter()是最基础的过滤方法。它使用指定的规则来过滤记录，下面的实例在数据库中找出body字段等于“SHAVE”的记录

```shell
>>> Note.query.filter(Note.body=='SHAVE').first()
<Note 'SHAVE'>
```

直接打印查询对象或将其转换为字符串可以看对应的SQL语句：

```shell
>>> print(Note.query.filter(Note.body=='SHAVE'))
SELECT note.id AS note_id, note.body AS note_body 
FROM note 
WHERE note.body = %(body_1)s
```

在filter()方法中传入表达式时，除了使用`==`以及表示不等于的`!=`，其他常用的过滤操作符如下：

- LIKE:

  ```shell
  filter(Note.body.like('%foo%'))
  ```

- IN:

  ```SHELL
  filter(Note.body.in_(['foo', 'bar', 'baz']))
  ```

- NOT IN:

  ```shell
  filter(~Note.body.in_['foo', 'bar', 'baz']))
  ```

- AND:

  ```shell
  # 1. 使用and_
  from sqlalchemy import and_
  filter(and_(Note.body == 'foo', Note.title == 'Foobaand_
  
  # 2. 在filter()中加入多个表达式，使用逗号分隔
  filter(Note.body == 'foo', Note.title == 'FooBar')
  
  # 3. 叠加调用多个filter()方法
  filter(Note.body == 'foo').filter(Note.title == 'FooBar')
  ```

- OR:

  ```shell
  from sqlalchemy import or_
  fliter(or_(Note.body == 'foo', Note.title == 'FooBar'))
  ```

和filter()方法相比，filter_by()方法更易于使用，在filter_by()方法中，你可以指定关键字表达式来指定过滤规则。更方便的是，你可以在这个过滤器中直接使用字段名称，如下：

```shell
Note.query.filter_by(body='SHAVE').first()
```

#### Update

更新一条记录非常简单，直接赋值给模型类的字段属性就可以改变字段值，然后调用commit()方法提交会话即可，如下：

```shell
>>> note = Note.query.get(2)
>>> note.body
"don't do that."
>>> note.body = "DON'T DO THAT."
>>> db.session.commit()
>>> note
<Note "DON'T DO THAT.">
```

> 只有插入新纪录或要将现有的记录添加到会话中时才需要使用add()方法，单纯要更新现有的记录时，只需要直接为属性赋新值，然后提交会话。

#### Delete

删除记录和添加记录很相似，不过要把add()方法换成delete()方法，最后都需要调用commit()方法提交记录。

```
>>> note = Note.query.get(2)
>>> db.session.delete(note).
>>> db.session.commit()
```



### 在视图函数里操作数据库

在视图函数里操作数据库的方式和在python shell中大致相同。我们创建一个简单的笔记程序，这个程序可以让你创建、编辑、删除笔记，并在主页列出所有保存后的笔记。

#### Create

创建填写新笔记的表单：

```python
class NewNoteForm(FlaskForm):
    body = TextAreaField('Body', validators=[DataRequired()])
    submit = SubmitField('Save')
```

我们创建一个new_note视图，这个视图负责渲染创建笔记的模板， 并处理表单的提交，如下：

```python
@app.route('/new', methods=['GET', 'POST'])
def new_note():
    form = NewNoteForm()
    if form.validate_on_submit():
        body = form.body.data
        note = Note(body=body)
        db.session.add(note)
        db.session.commit()
        flash('Your note is saved.')
        return redirect(url_for('index'))
    return render_template('new_note.html', form=form)
```

当表单被提交且通过验证时（即form.validate_on_submit()返回True），我们获取表单body字段的数据，然后创建新的Note实例，将表单中的body的值作为body参数传入，然后添加到数据库会话中并提交会话中。最后我们使用flash()函数发送提示消息并重定向到index视图。

表单在new_note.html模板中渲染，我们使用form_field宏来渲染表单字段，传入rows和cols参数定`制`<textarea>`输入框的大小，如下：

```html
{% block content %}
    <h2>New Note</h2>
    <form method="POST">
        {{ form.csrf_token }}
        {{ form_field(form.body, rows=5, cols=50) }}
        {{ form.submit }}
    </form>
{% endblock %}
```

#### Read

为了在主页中列出所有已保存的笔记，我们需要修改index视图，修改后的视图如下：

```python
@app.route('/')
def index():
    notes = Note.query.all()
    return render_template('index.html', notes=notes)
```

在index.html模板中渲染数据库记录，如下：

```html
{% block content %}
<h1>Notebook</h1>
<a href="{{ url_for('new_note') }}">New Note</a>
<h4>{{ notes | length }} notes:</h4>
{% for note in notes %}
    <div class="note">
        <p>{{ note.body }}</p>
    </div>
{% endfor %}
{% endblock %}
```

在模板中，我们迭代notes列表，调用Note对象的body属性(note.body)获取body字段的值，另外还通过length过滤器获取笔记的数量。

#### Update

更新一条笔记和创建一条新笔记的实现代码几乎完全相同，首先创建编辑笔记的表单：

```python
class EditNoteForm(FlaskForm):
       body = TextAreaField('Body', validators=[DataRequired()])
       submit = SubmitField('Update')
# 或通过继承NewNoteForm来实现
class EditNoteForm(NewNoteForm):
    submit = SubmitField('Update')
```

定义视图函数edit_note，用来渲染更新笔记页面和处理更新表单提交，如下：

```python
@app.route('/eidt/<int:note_id>', methods=['GET', 'POST'])
def edit_note(note_id):
    form = EditNoteForm()
    note = Note.query.get(note_id)
    if form.validate_on_submit():
        note.body = form.body.data
        db.session.commit()
        flash('Your note is updated.')
        return redirect(url_for('index'))
    form.body.data = note.body
    return render_template('edit_note.html', form=form)
```

这个视图通过URL变量note_id获取要被修改的笔记的主键值（id字段），然后通过get()方法获取到对应的Note实例。当表单被提交且通过验证时，我们将表单中body字段的值赋给note对象的body属性，然后提交数据库会话，这样就完成了更新操作。和创建笔记相同，我们接着发送提示消息并重定向到index视图。

需要注意的是，在GET请求的执行流程中，我们添加了如下代码：

```python
form.body.data = note.body
```

因为要添加修改笔记的功能，那么当我们打开修改某个笔记的页面是，这个页面的表单中必然要包含笔记原有的内容。使用WTFroms时，**当我们渲染表单字段时，如果表单字段的data属性不为空，WTForms会自动把data属性的值添加到表单字段的value属性中，作为表单的值填充进去，我们不用手动为value属性赋值**。因此，将存储笔记原有内容的note.body属性赋值给表单的dody字段的data属性，即可在页面上的表单中填入原有的内容。

在index.html模板中，我们需要在每个笔记内容下添加一个编辑按钮，用来访问编辑页面：

```html
{% for note in notes %}
    <div class="note">
        <p>{{ note.body }}</p>
        <a class="btn" href="{{ url_for('edit_note', note_id=note.id) }}">Edit</a>
    </div>
{% endfor %}
```

生成edit_note视图的URL中，我们传入当前note对象的id(note.id)作为URL变量note_id的值。

edit_note.html模板如下：

```html
{% block content %}
    <h2>Edit Note</h2>
    <form method="POST">
        {{ form.csrf_token }}
        {{ form_field(form.body, rows=5, cols=50) }}
        {{ form.submit }}
    </form>
{% endblock %}
```

#### Delete

删除note时，大多人通常会考虑在笔记内容下添加一个删除链接：

```html
<a class="btn" href="{{ url_for('delete_note', note_id=note.id) }}">Delete</a>
```

这个链接指向用来删除笔记的delete_note视图：

```python
@app.route('/delete/<int:note_id>')
   def delete_note(note_id):
       note = Note.query.get(note_id)
       db.session.delete(note)
       db.session.commit()
       flash('Your note is deleted.')
       return redirect(url_for('index'))
```

虽然看起来很合理，但这种处理方式会使程序处于CSRF攻击的风险之中。之前强调过，防范CSRF攻击的基本原则就是正确使用GET和POST方法。像删除这类修改数据的操作绝对不能通过GET请求实现，正确的做法是为删除操作创建一个表单，如下：

```python
class DeleteNoteForm(FlaskForm):
    submit = SubmitField('Delete')
```

这个表单只有一个提交字段，因为我们只需要在页面上显示一个删除按钮来提交表单。删除表单的提交请求由delte_note视图处理，如下：

```python
@app.route('/delete/<int:note_id>', methods=['POST'])
def delete_note(note_id):
    form = DeleteNoteForm()
    if form.validate_on_submit():
        note = Note.query.get(note_id)
        db.session.delete(note)
        db.session.commit()
        flash('Your note is deleted.')
    else:
        abort(400)
    return redirect(url_for('index'))
```

delete_not视图仅监听post请求。和编辑笔记视图类似，这个视图接收note_id作为参数。如果表单提交且通过验证（唯一需要验证的是CSRF令牌），就使用get()方法查询对应的记录，然后调用delete()方法删除并提交数据库会话。如果验证出错则使用abort()函数返回400错误响应。

因为删除按钮要在主页（即index.html）的笔记内容下添加，我们需要在index视图中实例化DeleteNoteForm类，然后传入模板。在index.html模板中，我们渲染这个表单：

```html
{% for note in notes %}
    <div class="note">
        <p>{{ note.body }}</p>
        <a class="btn" href="{{ url_for('edit_note', note_id=note.id) }}">Edit</a>
        <form method="POST" action="{{ url_for('delete_note', note_id=note.id) }}">
            {{ form.csrf_token }}
            {{ form.submit(class='btn') }}
        </form>
    </div>
{% endfor %}
```

我们将表单的action属性设置为删除当前笔记的URL。构建URL时，URL变量note_id的值通过note.id属性获取，当单击删除按钮时，会将请求发送到action属性中的URL。添加删除表单的目的主要就是防止CSRF攻击，所以不要忘记渲染form.csrf_token。



# 定义关系

在关系型数据库中，我们可以通过**关系**让不同表之间的字段建立联系。一般来说，定义关系需要两步，分别是创建外键和定义关系属性。在更复杂的多对多关系中，我们还需要定义关联表来管理关系。我们可以通过SQLAlchemy在模型之间建立关系模式。

### 配置Python shell上下文

当我们使用flask shell命令启动python shell时，每次都需要从app模块中导入db对象和相应的模型类，我们可以像Flask内置的app对象一样，把这些重复的操作自动集成到Python Shell上下文里。

使用`@app.shell_context_processor`装饰器注册一个shell上下文处理函数，它和模板上下文处理函数一样，需要返回包含变量和变量值的字段，如下：

```python
@app.shell_context_processor
def make_shell_context():
    return dict(db=db, Note=Note)
```

当你使用flask shell命令启动python shell时，所有使用@app.shell_context_processor装饰器注册的shell上下文处理函数会被自动执行，这会将db和Note对象推送到python shell上下文里：

```shell
>>> db
<SQLAlchemy engine=postgresql://zhengyaqi@localhost/db_demo>
>>> Note
<class 'app.Note'>
```

### 一对多

我们以作者和文章来演示一对多关系：一个作者可以写作多篇文章。Author类用来表示作者，Article类用来表示文章，如下：

```python
class Author(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(70), unique=True)
    phone = db.Column(db.String(20))
class Article(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(50), index=True)
    body = db.Column(db.Text)
```

我们将在这两个模型之间建立一个简单的一对多关系，建立这个一对多关系的目的是在表示作者的Author类中添加一个关系属性articles，作为集合（collection)属性，当我们对特定的Author对象调用articles属性，会返回所有相关的Article对象。

#### 定义外键

定义关系的第一步是创建外键。**外键(foreign key)是用来在A表存储B表的主键值，以便和B表建立联系的关系字段。**因为外键只能存储单一数据(标量)，所以外键总是在“多”的一侧定义。多篇文章属于同一个作者，所以我们需要为每篇文章添加外键，存储作者的主键值，以指向对应的作者。在Article模型中，我们定义一个author_id字段作为外键：

```python
class Article(db.Model):
    ...
    author_id = db.Cloumn(db.Integer, db.ForeignKey('author.id'))
```

这个字段使用`db.ForeignKey`类定义为外键，传入关系另一侧的表名和主键字段名，即author.id。实际的效果是将article表的author_id的值限制为author表的id列的值。它将用来存储author表中记录的主键值，如图所示：

<img src="https://i.loli.net/2021/09/17/eSuKznd85thDMpy.png" alt="image.png" style="zoom:80%;" />

> 外键字段的命名没有限制，因为要连接的目标字段是author表的id 列，所以为了便于区分而将这个外键字段的名称命名为author_id。

> 注意📢📢：传入ForeignKey类的参数author.id，其中author指的是Author模型对应的表名称，而id指的是字段名，即`表名.字段名`。迷行类对应的表名由Flask-SQLAlchemy生成，默认为类名称的小写形式，多个单词通过下划线分隔，也可以显示地通过`__tablename__`属性自己指定。

#### 定义关系属性

定义关系的第二步是使用关系函数定义关系属性。关系属性在关系的出发侧定义，即一对多关系的“一”这一侧。一个作者拥有多篇文章，在Author模型中，我们定义了一个articles属性来表示对应的多篇文章：

```python
class Author(db.Model):
    ...
    articles = db.relationship('Article')
```

> 关系属性的名称没有限制，可以自由修改。它相当于一个快捷查询，不会作为字段写入数据库中。

关系属性并没有使用Column类声明为列，而是使用了**db.relationship()**关系函数定义为关系属性，因为这个关系属性返回多个记录，我们称之为**集合关系属性**。

relationship()函数的第一个参数为关系另一侧的模型名称，它会告诉SQLAlchemy将Author类与Article类建立关系。当这个关系属性被调用时，SQLAlchemy会找到关系另一侧(即article表)的外键字段(即author_id)，然后反向查询article表中所有author_id为当前表主键值(即author.id)的记录，返回包含这些记录的列表，也就是返回某个作者对应的多篇文章记录。

创建一个作者及两篇文章，并添加到数据库会话中：

```shell
>>> foo = Author(name='foo')
>>> spam = Article(title='spam')
>>> ham = Article(title='ham')
>>> db.session.add(foo)
>>> db.session.add(spam, ham)
```

使用关系函数`db.relationship()`定义的属性不是数据库字段，而是类似于特定的查询函数，当某个Article对象被删除时，在对应Author对象的articles属性调用时返回的列表中也不会出现该对象。

在关系函数中，有很多参数可以用来设置调用关系属性进行查询时的具体行为，常用的关系函数参数如下：

| 参数名         | 说明                                                         |
| -------------- | ------------------------------------------------------------ |
| back_populates | 定义反向引用，用于建立双向关系，在关系的另一侧也必须显示定义关系属性 |
| backref        | 添加反向引用，自动在另一侧建立关系属性，是back_populates的简化版 |
| lazy           | 指定如何加载相关记录                                         |
| userlist       | 指定是否使用列表的形式加载记录，设置为False则使用标量（scalar) |
| casecade       | 设置级联操作                                                 |
| order_by       | 指定加载相关记录时的排序方式                                 |
| secondary      | 在多对多关系中指定关联表                                     |
| primaryjoin    | 指定多对多关系中的一级联结条件                               |
| secondaryjoin  | 指定多对多关系中的二级联结条件                               |

当关系属性被调用时，关系函数会加载相应的记录，下表列出了控制关系加载方式的lazy参数的常用选项：

常用的SQLAlchemy关系记录记载方式（lazy参数的可选值）：

| 关系加载方式 | 说明                                                         |
| ------------ | ------------------------------------------------------------ |
| select       | 在必要时一次性记载记录，返回包含记录的列表（默认值），等同于lazy=True |
| joined       | 和父查询一样加载记录，但是用联结，等同于lazy=False           |
| immediate    | 一旦父查询加载就加载                                         |
| subquery     | 类似于joined，不过将用于子查询                               |
| dynamic      | 不直接加载记录，而是返回一个包含相关记录的query对象，以便继续附加查询函数对结果进行过滤 |

> dynamic选项仅用于集合关系属性，不可用于多对一、一对一或是在关系函数中将uselist参数设为False的情况。
>
> 使用dynamic加载方式意味着每次操作关系都会执行一次sql查询，这会造成潜在的性能问题。大多数情况下我们只需要使用默认值select，只有在调用关系属性会返回大量记录，并且总是需要对关系属性返回附加额外的查询时，才需要使用动态加载（lazy=dynamic）

#### 建立关系

建立关系有两种方式：

1. 为外键赋值：

   ```shell
   >>> spam.author_id = 1
   >>> db.session.commit()
   ```

   提交数据库改动后，对foo对象调用articles属性，如下：

   ```shell
   >>> foo.articles
   [<Article 1>]
   ```

2. 通过操作关系属性，将关系属性赋值给实际的对象：

   集合关系属性可以像列表一样操作，调用append()方法来与Article对象建立关系

   > 也可以直接将关系属性赋值给一个包含Article对象的列表

   ```shell
   >>> foo.articles.append(ham)
   >>> db.session.commit()
   >>> ham.author_id
   1
   >>> foo.articles
   [<Article 1>, <Article 2>]
   ```

   与append()相对，对关系属性调用remove()方法可以与对应的Article对象解除关系：

   ```shell
   >>> foo.articles.remove(ham)
   >>> db.session.commit()
   >>> foo.articles
   [<Article 1>]
   ```

   >  也可以使用pop()方法操作关系属性，它会与关系属性对应的列表的最有一个Article对象接触关系并返回该对象。



#### 建立双向关系

我们在Authors类中定义了集合关系属性articles，用来获取某个作者拥有的多篇文章记录。在某些情况下，你也许希望能在Article类中定义一个类似的author关系属性，当被调用时返回对应的作者记录，这类返回单个值得关系属性被称为**标量关系属性**。而这种两侧都添加关系属性获取对方记录的关系我们称之为**双向关系(bidirectional relationship)**。

双向关系不是必须的，但在某些情况下非常方便。双向关系的建立很简单，通过再关系的另一侧也创建一个relationship()函数，我们就可以在两个表之间建立双向关系。我们使用作家（Writer）和书（Book）的一对多关系来进行演练，建立双向关系后代码如下：

```python
class Writer(db.Model):
    id = db.Column(id.Integer, primary_key=True)
    name = db.Column(db.String(70), unique=True)
    books = db.relationship('Book', back_populates='writer')


class Book(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(50), index=True)
    writer_id = db.Column(db.integer, db.ForeignKey('writer.id'))
    writer = db.relationship('Writer', back_populates='books')
```

在多的一侧Book类中，我们新创建了一个writer关系属性，这是一个标量关系属性，调用它会获取对应的Writer记录，而在Writer类中books属性则用来获取对应的多个Book记录。在关系函数`db.relationship()`中，我们使用`back_populates`参数来连接对方，`back_populates`参数的值需要设为关系另一侧的关系属性名。

我们先创建一个Writer和两个Book记录，并提交到数据库：

```shell
>>> king = Writer(name='Stephen King')
>>> carrie = Book(title='Carrie')
>>> it = Book(title='IT')
>>> db.session.add(king)
>>> db.session.add(carrie, it)
>>> db.session.commit()
```

设置双向关系后，除了通过集合关系属性books来操作关系，我们也可以使用标量关系属性writer来操作关系：

```shell
>>> carrie.writer = king
>>> carrie.writer
<Writer 'Stephen King'>
>>> king.books
[<Book 'Carrie'>]
>>> it.writer = king
>>> king.books
[<Book 'Carrie'>, <Book 'IT'>]
```

相对的，将某个Book的writer设置为None，就会接触与对应Writer对象的关系：

```shell
>>> it.writer = None
>>> king.books
[<Book 'Carrie'>]
```

需要注意的是，我们只需要在关系的一侧操作关系。当为Book对象的writer属性赋值后，对应Writer对象的books属性的返回值也会自动包含这个Book对象。泛指，当某个Writer对象被删除时，对应的Book对象的writer属性被调用时的返回值也会被设置为空。

#### 使用backref简化关系定义

在介绍关系函数的参数时，我们曾提到，使用关系函数中的backref参数可以简化双向关系的定义。以一对多为例，backref参数用来自动为关系另一侧添加关系属性，作为反向引用（back reference)，赋予的值会作为关系另一侧的关系属性名称。比如，我们在Author一侧的关系函数中将backref参数设为author，SQLAlchemy会自动为Article类添加一个author属性。我们使用Singer和Song作为演示：

```python
class Singer(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(70), unique=True)
    songs = db.relationship('Song', baclkref='singer')

class Song(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(50), index=True)
    singer_id = db.Column(db.Integer, db.ForeignKey('singer.id'))
```

在定义集合属性songs的关系函数中，我们将backref参数设为singer，这会同时在Song类中添加一个singer的标量属性。这是我们仅需要定义一个关系函数，虽然singer是一个看不见的关系属性，但在使用上和定义两个关系函数并使用back_populates参数的效果完全相同。

需要注意的是，使用backref允许我们仅在关系的一侧定义另一侧的关系属性，但在某些情况下，我们希望可以对在关系另一侧的关系属性进行设置，这时就需要使用backref()函数。backref()函数接收第一个参数作为在关系另一侧添加的关系属性名，其他关键字参数会作为关系另一侧关系函数的参数传入。比如我们要在关系另一侧”看不见的relationship()函数”中将uselist设置为False，可以这么实现：

```python
class Singer(db.Model):
  ...
  songs = db.relationship('Song', backref=backref('singer', userlist=False))
```

> 尽管使用backref非常方便，但通常来说“显式好过隐式”，所以我们应该尽量使用back_populates定义双向关系。



#### 邻接列表关系（Adjacency List Raltionship）

定义一个文章模型Post、评论模型Comment，Post与Comment之间是一对多的关系，同时评论要支持回复。我们想要为评论添加回复，并在获取某个评论时，可以通过关系属性获得相对应的回复，这样就可以在模板中显示出评论之间的对应关系。那么回复如何定义呢？

当然可以再为回复创建一个Reply模型，然后使用一对多关系将评论Comment和回复Reply关联起来。但是有一个更简单的解决办法，因为回复本身也是评论，如果可以再评论模型内部建立层级关系，那么就可以在一个模型中表示评论和回复。

**这种在一个模型内的一对多关系在SQLAlchemy中被称为邻接列表关系（Adjacency List Raltionship）。**

具体来说，我们需要再Comment模型内添加一个外键指向它自身。这样我们就得到一种层级关系：每个评论对象都可以包含多个子评论，即回复。Comment模型如下：

```python
class Comment(db.Model):
  id = db.Column(db.Integer, primary_key=True)
  author = db.Column(db.String(30))
	body = db.Column(db.Text)
  replied_id = db.Column(db.Integer, db.ForeignKey('comment.id'))
  replied = db.relationship('Comment', back_populates='replies', remote_side=[id])
  replies = db.relationship('Comment', back_populates='replied', cascade='all')
```

我们添加replied_id字段，通过db.ForeignKey()设置一个外键指向资深的id字段。

关系两册的关系属性都在Comment模型中定义，需要特别说明的是，表示被回复的评论（即父对象）的标量关系属性replied的定义：

这个关系和之前的一对多关系基本相同。仔细回想一下一对多关系的设置，我们需要在”多”的这一侧定义外键，这样SQLAlchemy就会知道哪边是”多”的一侧，这是关系对”多”的一侧来说就是多对一关系。但是在邻接列表关系中，关系的两侧都在同一个模型中，这是SQLAlchemy无法分辨关系的两侧，所在在这个关系函数中，通过将remote_side参数设为id字段，我们就可以把id字段定义为关系的远程侧（remote side），而replied_id就相应地变为本地侧（local side），这样反向关系就被定义为多对一，即多个回复对应一个富平路。

集合关系属性replies中的cascade参数设为all，因为我们期望的效果是，当父评论被删除时，所有的子评论也随之删除。



### 多对一

一对多关系反过来就是多对一关系，这两种关系模式分别从不同的视角出发。一个作者拥有多篇文章，反过来就是多篇文章属于同一个作者。我们用居民Citizen和城市City来演示多对一关系，多个居民居住于同一城市。

建立多对一关系后，我们将在Citizen类中创建一个标量关系属性，调用它可以获取单个City对象。

**需要注意的是，关系属性在关系模式的出发侧定义**。当出发点在“多”这一侧时，我们希望在Citizen类中添加一个关系属性city来获取对应的城市对象，因为这个关系属性返回单个值，我们称之为标量关系属性。**在定义关系时，外键总是在“多”这一侧定义，所以多对一关系中外键和关系属性都定义在“多”这一侧**。

```python
class Citizen(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(70), unique=True)
    city_id = db.Column(db.Integer, db.ForeignKey('city.id'))
    city = db.relationship('City')

class City(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(70), unique=True)
```

这是定义的city关系属性是一个标量属性（返回单一数据）。当Citizen.city被调用时，SQLAlchemy会根据外键字段city_id存储的值查找对应的City对象并返回，即居民记录对应的城市记录。

当建立双向关系时，如果不使用backref，那么一对多关系和多对一关系模式在定义上完全相同，这时可以将一对多和多对一视为同一种关系模式。



### 一对一

我们用国家Country和首都Capital来演示一对一关系，每个国家只有一个首都；反过来说，一个城市也只能作为一个国家的首都。

建议一对一关系手，我们将在Country类中建立一个标量关系属性capital，调用它会获取单个Capital对象；还将在Capital中建立一个标量关系属性country，调用它会获取单个Country对象。

一对一关系实际上是通过建立双向关系的一对多关系的基础上转换而来。我们要确保关系两侧的关系属性都是标量属性，都只返回单个值，所以要在定义集合属性的关系函数中将userlist参数设为False，这是一对多关系转换为一对一关系，代码如下：

```python
class Country(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(30), unique=True)
    capital = db.relationship('Capital', uselist=False)

class Capital(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(30), unique=True)
    country_id = db.Column(db.Integer, db.ForeignKey('country.id'))
    country = db.relationship('Country')
```

**“多”这一侧本身就是标量关系属性，不用做任何改动。**而“一”这一侧的集合关系属性，通过将uselist设为False后，将仅返回对应的单个记录，而且无法在使用列表语义操作：

```shell
>>> china = Country(name='China')
>>> beijing = Capital(name='BeiJing')
>>> db.session.add(china)
>>> db.session.add(beijing)
>>> db.session.commit()
>>> china.capital = beijing 
>>> china.capital
<Capital 'BeiJing'>
>>> beijing.country
<Country 'China'>
>>> tokyo = Capital(name='Tokyo')
>>> china.capital.append(tokyo)
Traceback (most recent call last):
  File "<console>", line 1, in <module>
AttributeError: 'Capital' object has no attribute 'append'
```



### 多对多

我们使用学生和老师演示多对多关系：每个学生有多个老师，每个老师有多个学生。

我们用Student类表示学生，Teacher类表示老师。在这两个模型之间建立多对多关系后，我们需要在Student类中添加一个集合关系属性teachers，调用它可以获取某个学生的多个老师，而不同的学生可以和同一个老师建立关系。

在一对多关系中，我们可以在`多`这一侧添加外键指向`一`这一侧，外键只能存储一个记录，但是在多对多关系中，每一个记录都可以与关系另一侧的多个记录建立关系，关系两侧的模型都需要存储一组外键。在SQLAlchemy中，要想建立多对多关系，除了关系两侧的模型外，我们还需要创建一个关联表（association table）。关联表不存储数据，只用来存储关系两侧的外键对应关系，如下：

```python
association_table = db.Table('assciation', 
     db.Column('student_id', db.Integer, db.ForeignKey('student.id')),
     db.Column('teacher_id', db.Integer, db.ForeignKey('teacher.id')))

class Student(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(70), unique=True)
    grade = db.Column(db.String(20))
    teachers = db.relationship('Teacher', secondary=association_table, back_populates='students')

class Teacher(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(70), unique=True)
    office = db.Column(db.String(20))
    students = db.relationship('Student', secondary=association_table, back_populates='students')
```

关联表使用 `db.Table`类定义，传入的第一个参数是关联表的名称。我们在关联表中定义了两个外键字段：teacher_id字段存储Teacher类的主键，student_id字段存储Student类的主键。借助关联表这个中间人存储的外键对，我们可以把多对多关系分化为两个一对多关系，如图：

<img src="https://i.loli.net/2021/09/28/sa7wnyfjXITKFPe.png" alt="image.png" style="zoom:85%;" />

当我们需要查询多个学生记录的多个老师时，我们先通过学生和关联表的一对多关系查找所有包含该学生的关联表记录，然后就可以从这些记录中再进一步获取每个关联表记录包含的老师记录。

我们在Student类中定义一个teachers关系属性用来获取老师集合。在多对多关系中定义关系函数，除了第一个参数是关系另一侧的模型名称外，我们还需要添加一个 `secondary` 参数，把这个值设为关联表的名称。

为了便于实现真正的多堆垛关系，我们需要建立双向关系。建立双向关系手，多对多关系会变得更直观。在Teacher类上的students集合会返回所有关联的学生记录，而Student类上的teachers集合会返回所有关联的老师记录。

除了在声明关系时有所不同，对多对关系模式在操作关系时和其他关系模式基本相同。调用关系属性student.teachers时，SQLAlchemy会直接返回关系另一侧的Teacher对象，而不是关联表记录，反之亦同。和其他关系模式中的集合关系属性一样，我们可以将关系属性teachers和students像列表一样操作。

> 📢📢：关联表由SQLAlchemy接管，它会帮我们管理这个表：我们只需要像往常一样通过操作关系来建立或解除关系，SQLAlchemy会自动在关联表中创建或删除对应的关联表记录，而不用手动操作关联表。





# 更新数据库表

模型类（表）不是一成不变的，当你添加了新的模型类，或是在模型类中添加了新的字段，甚至是修改了字段的名称或类型，都需要更新表，但数据库表并不会随着模型的修改而自动更新，下面我们就来看看如何更新数据库表。



###  重新生成表

重新调用create_all()并不会起到更新表或重新创建表，如果你并不在意表中的数据，最简单的方法是使用drop_all()方法删除表及其中的数据，然后再使用create_all()方法重新创建。

为了开发方便，我们修改initdb命令函数的内容，为其增加一个`--drop`选项来支持删除表和数据库后进行重建：

```python
@app.cli.command()
@click.option('--drop', is_flag=True, help='Create after drop')
def initdb(drop):
    if drop:
        click.confirm('This operation will delete the database, do you want to continue?', abort=True))
        db.drop_all()
        click.echo('Drop tables.')
    db.create_all()
    click.echo('Initialized database.')
```

这这个命令函数前，我们使用click提供的option装饰器为命令添加了一个`--drop`选项，将is_flag参数设置为True可以将这个选项声明为布尔值标志（boolean flag）。`--drop`选项的值作为drop参数传入命令函数，如果提供了这个选项，那么drop的值将是True，否则为False。因为添加`--drop`选项会直接清空数据库内容，如果需要，也可以通过click.command()函数添加一个确认提示，这样只有输入y或yes才会继续执行操作

```shell
$ flask initdb --drop
This operation will delete the database, do you want to continue? [y/N]: y
Drop tables.
Initialized database.
```



### 使用Flask-Migrate迁移数据库

SQLAlchemy的开发者Michael Bayer写了一个数据库迁移工具——Alembic来帮助我们实现数据库的迁移，数据库迁移攻击可以在不破坏数据的情况下更新数据库表的结构。蒸馏器（Alembic）是炼金士最重要的攻击，要学习SQL炼金术（SQLAlchemy)，我们当然要掌握蒸馏器的使用。

扩展Flask-Migrate集成了Alembic，提供了一些flask命令来简化迁移工作，我们将使用它来迁移数据库。Flask-Migrate及其依赖，可以使用pip进行安装：

```shell
$ pip install flask-migrate
...
Installing collected packages: Mako, alembic, flask-migrate
Successfully installed Mako-1.1.5 alembic-1.7.3 flask-migrate-3.1.0
```

在程序中，我们实例化Flask_Migrate提供的Migrate类，进行初始化操作：

```python
from flask import Flask
from flask_migrate import Migrate
from flask_sqlalchemy import SQLAlchemy

...
app = Flask(__name__)
db = SQLAlchemy(app)
migrate = Migrate(app, db)
```

在实例化Migrte类时，除了传入程序实例app，还需要传入实例化Flask-SQLAlchemy提供的SQLAlchemy类创建的db对象作为第二个参数。

####  1. 创建迁移环境

在开始迁移数据之前，需要先试用下面的明亮创建一个迁移环境：

```shell
$ flask db init
```

> Flask-Migrate提供了一个命令集，使用db作为命令集名称，它提供的命令都以flask db开头。

迁移环境只需要创建一次。这回在你的项目根目录下创建一个migrations文件夹，其中包含了自动生成的配置文件和迁移版本文件夹。

#### 2. 生成迁移脚本

使用migrate子命令可以自动生成迁移脚本：

```shell
$ flask db migrate -m "add subject for teacher"
...
INFO  [alembic.autogenerate.compare] Detected added column 'teacher.subject'
  Generating /Users/zhengyaqi/.virtualenvs/env_for_test/database_demo/migrations/versions/5bd7e7184fb6_add_subject_for_teacher.py ...  done
```

这条命令可以简单理解为在flask里对数据库（db）进行迁移（migrate)。`-m` 选项用来添加迁移备注信息。从输出的信息中可以看到，Alembic检测除了模型的变化：表teacher新添加了subject列，并相应地生成了一个迁移脚本bd7e7184fb6_add_subject_for_teacher.py，脚本内容如下：

```python
"""add subject for teacher

Revision ID: 5bd7e7184fb6
Revises: 
Create Date: 2021-09-28 17:55:54.114737

"""
from alembic import op
import sqlalchemy as sa

# revision identifiers, used by Alembic.
revision = '5bd7e7184fb6'
down_revision = None
branch_labels = None
depends_on = None

def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('teacher', sa.Column('subject', sa.String(length=70), nullable=True))
    # ### end Alembic commands ###

def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_column('teacher', 'subject')
    # ### end Alembic commands ###
```

迁移脚本主要包含了两个函数：`upgrade()`函数用来将改动应用到数据库，函数中包含了向teacher表中添加subject字段的命令；而`downgrade()`函数用来撤销改动，包含了删除subject字段的命令。

> 📢📢：如这两个函数中的注释所说，迁移命令是由Alembic自动生成的，其中可能包含错误，所以有必要生成后再检查一下。

因为每一次迁移都会生成新的迁移脚本，而且Alembic为每一次迁移都生成了修订版本（revision）ID，所以数据库可以恢复到修改历史中的任一点。

有些复杂的操作无法实现自动迁移，这时可以使用revision命令手动创建迁移脚本。这同样会生成一个迁移脚本，不过脚本中的upgrade()和downgrade()函数都是空的，你需要使用Alembic提供的Operations对象指令在这两个函数中实现具体操作。

#### 3. 更新数据库

生成了迁移脚本后，使用upgrade子命令即可更新数据库：

```shell
$ flask db upgrade
INFO  [alembic.runtime.migration] Context impl PostgresqlImpl.
INFO  [alembic.runtime.migration] Will assume transactional DDL.
INFO  [alembic.runtime.migration] Running upgrade  -> 5bd7e7184fb6, add subject for teacher
```

如果还没有创建数据库和表，这个命令会自动创建；如果已经创建，则会在不损坏数据的前提下执行更新。

如果你想回滚迁移，那么可以使用downgrade命令（降级），它会撤销最后一次迁移在数据库中的改动。





# 数据库进阶

### 级联操作

`Cascade`意为`级联操作`，就是在操作一个对象的同时，对相关的对象也执行某些操作。我们通过一个Post模型和Comment模型来演示级联操作，分别表示文章和评论，二者为一对多的关系：

```python
class Post(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(50), unique=True)
    body = db.Column(db.Text)
    commnets = db.relationship('Comment', back_populates='post')

class Comment(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    body = db.Column(db.Text)
    post_id = db.Column(db.Integer, db.ForeignKey('post.id'))
    post = db.relationship('Post', back_populate='comments')
```

级联操作行为通过关系函数relationship()的cascade参数设置。我们希望在操作Post对象时，处于附属地位的Comment对象也被相应执行某些操作，这时应该在Post类的关系函数中定义级联参数。设置了cascade参数的一侧被视为父对象，相关的对象则被视为子对象。

cascade通常使用多个组合值，级联值之间使用逗号分隔，比如：

```python
class Post(db.Model):
  ...
  comments = db.relationship('Comment', cascade='save-update, merge, delete')
```

常用的配置组合如下所示：

- save-update、merge（默认值）
- save-update、merge、delete
- all
- all、delete-orphan

当没有设置cascade参数时，会使用默认值save-update、merge。上面的all等同于除了delete-orphan以外所有可用值的组合，即save-update、merge、refresh-expire、expunge、delete。下面分别介绍常用的级联值：



1. **save-update**

   save-update是默认的级联行为，当cascade参数设为save-cascade时，如果使用db.session.add()方法将Post对象添加到数据库会话时，那么与Post相关联的Comment对象也将会被添加到数据库会话。

   首先创建Post和Comment对象：

   ```shell
   >>> post1 = Post(title='post1')
   >>> comment1 = Comment(body='comment1')
   >>> comment2 = Comment(body='comment2')
   ```

   将post1添加到数据库会话后，只有post1在数据库会话中：

   ```shell
   >>> db.session.add(post1)
   >>> post1 in db.session
   True           
   >>> comment1 in db.session, comment2 in db.session
   (False, False)
   ```

   如果让post1和这两个Comment对象建立关系，那么这两个Comment对象也会自动被添加到数据库会话中：

   ```shell
   >>> post1.comments.append(comment1)
   >>> post1.comments.append(comment2)
   >>> comment1 in db.session, comment2 in db.session
   (True, True)
   ```

   当调用db.session.commit()提交数据库会话时，这三个对象都会被提交到数据库中。

2. **delete**

   如果某个Post对象被删除，那么按照默认行为，该Post对象相关联的所有Comment对象都将取消关联，外键字段的值会被清空。如果Post类的关联函数中cascade参数设为delete时，这项相关的Comment会在关联的Post对象删除时被一并删除。当需要设置delete级关联时，我们会将级联值设为all或save-update、merge、delete，比如：

   ```python
   class Post(db.Model):
     ...
     comments = db.relationship('Comment', cascade='all')
   ```

3. **delete-orphan**

   这个模式是基于delete级联的，必须和delete级联一起使用，通常会设为all、delete-orphan，因为all包含delete。因此cascade参数设为delete-orphan时，它首先包含delete级联的行为：当某个Post对象被删除时，所有相关的Comment对象都将被删除（delete级联）。除此之外，当某个Post对象（父对象）与某个Comment对象（子对象）解除关系时，也会删除该Comment对象，这个解除关系的对象被称为**孤立对象（orphan object）**。现在comments属性中的级联值为all、delete-orphan：

   ```python
   class Post(db.Model):
     ...
     comments = db.relationship('Comment', cascade='all, delete-orphan')
   ```

   先创建Post对象post2和Comment对象comment3、comment4，并将他们进行关联：

   ```shell
   >>> post2 = Post(title='post2')
   >>> comment3 = Comment(body='comment3')
   >>> comment3 = Comment(body='comment3')
   >>> post2.comments.append(comment3)
   >>> post2.comments.append(comment4)
   >>> db.session.add(post2)
   >>> Post.query.all()
   [<Post 'post1'>, <Post 'post2'>]
   >>> Comment.query.all()
   [<Comment 'comment1'>, <Comment 'comment2'>, <Comment 'comment3'>, <Comment 'comment4'>]
   ```

   下面我们将comment3、comment4与post2解除关系，并提交到数据库会话：

   ```shell
   >>> post2.comments
   [<Comment 'comment3'>, <Comment 'comment4'>]
   >>> post2.comments.pop()
   <Comment 'comment4'>
   >>> post2.comments.pop()
   <Comment 'comment3'>
   ```

   默认情况下，相关评论对象的外键会被设置为空值。因为我们设置了delete-orphan级联，所以现在你会发现解除关系的两条评论记录都被删除了

   ```shell
   >>> post2.comments
   []
   >>> Comment.query.all()
   [<Comment 'comment1'>, <Comment 'comment2'>]
   >>> Post.query.all()
   [<Post 'post1'>, <Post 'post2'>]
   ```

   delete和delete-orphan通常会在一对多关系模式中，而且“多”这一侧的对象附属于“一”这一侧的对象时使用。尤其是如果“一”这一侧的“父”对象不存在了，那么“多”这一侧的“子”对象不再有意义的情况。这种情况下，如果不使用级联操作，那么我们就需要手动迭代关系另一侧的所有评论对象，然后一一进行删除操作。



### 事件监听

在Flask中，我们可以使用Flask提供的多个装饰器注册请求回调函数，它们会在特定的请求处理环节被执行。类似的，SQLAlchemy也提供了一个listen_for()装饰器，它可以用来注册事件回调函数。

listens_for()装饰器主要接收两个参数，target表示监听的对象，这个对象可以是模型类、类实例或类属性等。identifier参数表示被监听事件的标识符，比如，用于监听属性的时间标识符有set、append、remove、ini_scalar、init_collention等。

为了演示事件监听，我们创建一个Draft模型类表示草稿，其中包含body字段和edit_time字段，分别存储草稿正文和被修改的次数，其中edit_time的默认值为0，如下：

```python 
class Draft(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    body = db.Column(db.Text)
    edit_time = db.Column(db.Integer, default=0)
```

通过注册事件监听函数，我们可以实现在body列修改时，自动叠加表示被修改次数的edit_time字段。在SQLAlchemy中，每个事件都会有一个对应的事件方法，不同的事件方法支持不同的参数。被 注册的监听函数需要接收对应事件方法的所有参数，所以具体的监听函数用法因使用的时间而异。

设置某个字段值将触发set时间，为set时间编写事件监听函数如下：

```python
@db.event.listens_for(Draft.body, 'set')
def increment_edit_time(target, value, oldvalue, initiator):
    if target.edit_time is not None:
        target.edit_time += 1
```

我们在listens_for()装饰器中分别传入Draft.body和set作为target和identifier参数的值。监听函数接收所有set()事件方法接收的参数，其中target参数表示触发事件的模型类实例，使用target.edit_time即可获取我们需要叠加的字段。其他的参数也需要照常写出，虽然这里没有用到。value表示被设置的值，oldvalue表示被取代的旧值：

当set事件发生在目标对象Draft.body上时，这个监听函数就会被执行，从而自动叠加Draft.edit_time列的值，如下：

```shell
>>> draft = Draft(body='init')
>>> db.session.add(draft)
>>> db.session.commit()
>>> draft.edit_time
0
>>> draft.body = 'first edit'
>>> draft.edit_time
1
>>> draft.body = 'second edit'
>>> draft.edit_time
2
>>> draft.body = 'third edit'
>>> draft.edit_time
3
```

除了这种传统的参数接收方式，即接收所有事件方法接收的参数，还有一种更简单的方法。通过在listens_for()装饰器中将关键字参数name设为True，可以在监听函数中接收`**kwargs`作为参数（可边长关键字参数），即“name argument”。然后在函数中可以使用参数名作为键来从`**kwargs`字典获取对应的参数值：

```python
@db.event.listens_for(Draft.body, 'set', named=True)
def increment_edit_time(**kwargs):
    if kwargs['target'].edit_time is not None:
        kwargs['target'].edit_time += 1
```



