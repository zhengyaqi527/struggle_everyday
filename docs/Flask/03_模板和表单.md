# 模板与模板引擎

在动态Web程序中，视图函数返回的HTML数据往往需要根据相应的变量(如查询参数)动态生成。当HTML代码保存到单独的文件重视，我们没办法再使用字符串格式化或拼接字符串的方式来在HTML代码中插入变量，这时我们需要使用模板引擎(template engine)。借助**模板引擎，我们可以在HTML文件中使用特殊的语法标记出变量，这类包含固定内容和动态部分的可重用文件称为模板（template）。**

模板引擎的作用就是读取并执行模板中的特殊语法标记，并根据传入的数据将变量替换为实际值，输出最终的HTML页面，这个过程被称为渲染（rendering）。

FLask默认使用的模板引擎是Jinja2，它是一个功能齐全的python模板引擎，除了设置变量，还允许我们在模板中添加if判断、执行for迭代、调用函数等，以各种方式控制模板的输出。对于Jinja2来说，模板可以是任何格式的纯文本文件，比如HTML、XML、CSV、LaTex等。



# 模板的基本用法

- 定界符

  在模板中添加python语句和表达式时，我们需要使用定界符把他们标记出来，三种常见的定界符如下：

  - 语句：如if判断、for循环等

    ```html
    {% ... %}
    ```

  - 表达式：如字符串、变量、函数调用等

    ```html
    {{ ... }}
    ```

  - 注释

    ```html
    {# ... #}
    ```

  另外，在模板中，Jinja2支持使用`.`获取变量的属性，如user字典中的username键值通过`.`获取，即`user.username`，效果上等同于`user['username']`。

- 模板语法

  利用Jinja2这样的模板引擎，我们可以将一部分的逻辑程序放到模板中去，即在模板中使用python语句和表达式来操作数据的输出。但Jinja2并不支持所有的python语法，而且出于效率和代码组织等方面的考虑，应该适度使用模板，仅把和输出控制有关的逻辑操作放到模板中。

  Jinja2允许你在模板中使用大部分Python对象，比如字符串、列表、字典、元组、整型、浮点型、布尔值。它支持基本的运算符号（+、-、*、/等）、比较符号（==、!=等）、逻辑符号（and、or、not）以及in、 is 、None和布尔值（True、False）。

  在for循环内，Jinja2提供了多个特殊变量，常见的循环变量如下：

  | 变量名         | 说明                          |
  | -------------- | ----------------------------- |
  | loop.index     | 当前迭代数（从1开始计数）     |
  | loop.index0    | 当前迭代数（从0开始计数）     |
  | loop.revindex  | 当前反向迭代数（从1开始计数） |
  | loop.revindex0 | 当前方向迭代数（从0开始计数） |
  | loop.first     | 如果是第一个元素，则为True    |
  | loop.last      | 如果是最后一个元素，则为True  |
  | loop.preitem   | 上一个迭代的条目              |
  | Loop.nextitem  | 下一个迭代的条目              |
  | Loop.length    | 序列包含的元素数量            |

- 渲染模板

  渲染一个模板，就是执行模板中的代码，并传入所有在模板中使用的变量，渲染后的结果就是我们要返回给客户端的HTML响应。在视图函数中渲染模板时，我们并不直接使用Jinja2提供的函数，而是使用Flask提供的渲染函数`render_template()`。

  在`render_template()`函数中，我们首先传入模板的文件名作为参数。Flask会在根目录下的templates文件夹中寻找模板文件，所以这里传入的文件路径是相对于templates文件夹的。除了模板文件路径，我们还是关键字参数的形式传入了模板中使用的变量值。

  ```python
  from flask import Flask, render_template
  ...
  @app.route('/watchlist')
  def watchlist():
    return render_template('watchlist.html', user=user, movies=movies)
  ```

  

# 模板辅助工具

除了基本语法，Jinja2还提供了许多方便的攻击，这些工具可以让你更方便地控制模板的输出。

- 模板上下文

  模板上下文包含了很多变量，其中包括我们调用`render_template()`函数时手动传入的变量以及Flask默认传入的变量。

  除了渲染时传入变量，你也可以在模板中定义变量，使用set标签：

  ```html
  {% set navigation = [('/', 'Home'), ('/about', 'About')] %}
  ```

  也可以将一部分模板数据定义为变量，使用set和endset标签声明开始和结束

  ```html
  {% set navigation %}
  	<li><a href="/">Home</a>
    <li><a href="/about">About</a>
  {% endset %}
  ```

  - 内置上下文变量

    Flask在模板上下文中提供了一些内置变量，可以在模板中直接使用，如下：

    | 变量    | 说明                                           |
    | ------- | ---------------------------------------------- |
    | config  | 当前的配置对象                                 |
    | request | 当前的请求对象，在已激活的请求环境下可用       |
    | session | 当前的会话对象，在已激活的请求环境下可用       |
    | g       | 与请求绑定的全局变量，在已激活的请求环境下可用 |

  - 自定义上下文

    如果多个模板都需要使用同一变量，那么比起在多个视图函数中重复传入，更好的方法是能够设置一个模板全局变量。Flask提供了一个`@app.context_processor`装饰器，可以用来注册模板上下文处理函数，它可以帮我们完成统一传入变量的工作。这个函数需要返回包含变量键值对的字典，如下所示：

    ```python
    @app.context_processor
    def inject_foo():
      foo = 'I am foo'
      return dict(foo=foo) # 除了传入字符串、列表等数据结构，还可以传入函数、类或类实体等
    ```

    当我们直接调用render_template()函数渲染任意一个模板时，所有使用`@app.context_processor`装饰器注册的模板上下文处理函数（包括Flask内置的上下文处理函数）都会被执行，这些函数的返回值会被添加到模板中，因此我们可以再模板中直接使用foo变量。

- 全局对象

  全局对象是指在所有的模板中都可以直接使用的对象，包括在模板中导入的模板。

  - **全局函数**

    - 内置全局函数

      Jinja2在模板中默认提供了一些全局函数，常用的三个函数如下表：

      | 函数                                    | 说明                                                         |
      | --------------------------------------- | ------------------------------------------------------------ |
      | range([start, ]stop[, step])            | 与python中range用法相同                                      |
      | lipsum(n=5, html=True, min=20, max=100) | 生成随机文本，可以在测试时用来填充页面。默认生成5段html文本，每段包含20-100个单词 |
      | dict(**items)                           | 和python中的dict()用法相同                                   |

      除了Jinja2内置的全局函数，Flask也在模板中内置了两个全局函数，如下表：

      | 函数                   | 说明                    |
      | ---------------------- | ----------------------- |
      | url_for()              | 用来生成URL的函数       |
      | get_flashed_messages() | 用来获取flash消息的函数 |

    - 自定义全局函数
    
      除了使用`@app.context_processor`注册模板上下文处理函数来传入函数，我们也可以使用`@app.template_global`装饰器直接将函数注册为模板全局函数，如下：
    
      ```python
      # 使用@app.template_global直接将函数注册为模板全局函数
      @app.template_global()
      def bar:
        return 'I am bar.'
      
      # 使用@app.context_processor注册模板上下文处理函数来传入函数
      def foo():
        retnrun 'I am foo'
      @app.context_processor
      def inject_foo():
        return dict(foo=foo)
      ```
    
      默认使用函数的原名称传入模板(此处为bar)，在`app.template_global()`装饰器中使用name参数可以指定一个自定义名称。
    
      也可以使用`app.add_template_global()`方法注册自定义全局函数，传入函数对象和可选的自定义名称(name)，如
    
      ```python
      def bar():
        return 'I am bar.'
      app.add_template_global('bar', name='Bar')
      ```
    
      

  - **过滤器**

    在Jinja2中，过滤器（filter）是一些可以用来修改和过滤变量值的特殊函数，过滤器和变量用一个竖线（管道符号）隔开，需要参数的过滤器可以像函数一下使用括号传递。

    - 内置过滤器

      Jinja2提供了许多内置过滤器，常用的如下表：
  
      | 过滤器                                                       | 说明                                                         |
      | ------------------------------------------------------------ | ------------------------------------------------------------ |
      | default(value, default_value='u', boolean=False)             | 设置默认值，默认值作为参数传入，别名为d                      |
      | escape(s)                                                    | 转义html文本，别名为e                                        |
      | first(seq)                                                   | 返回序列的第一个元素                                         |
      | last(seq)                                                    | 返回序列的最后一个元素                                       |
      | length(object)                                               | 返回变量的长度                                               |
      | random(seq)                                                  | 返回序列中的随机元素                                         |
      | safe(value)                                                  | 将变量值标记为安全，避免转义                                 |
      | trim(value)                                                  | 清楚变量值前后的空格                                         |
      | max(value, case_sensitive=False, attribute=None)             | 返回序列中的最大值                                           |
      | min(value, case_sensitive=False, attribute=None)             | 返回序列中的最小值                                           |
      | unique(value, case_sensitive=False, attribute=None)          | 返回序列中不重复的值                                         |
      | striptages(value)                                            | 清楚变量值内的HTML标签                                       |
      | urlize(value,)trim_url_limit=None, nofollow=False, target=None, rel=None) | 将url文本变为可单击的html链接                                |
      | wordcount(s)                                                 | 计算单词数量                                                 |
      | tojson(value, indent=None)                                   | 将变量值转换为JSON格式                                       |
      | truncate(s, length=255, killwords=False, end='...', leeway=None) | 截断字符串，常用于显示文章摘要，length参数设置截断的长度，killwords参数设置是否截断单词， end参数设置结尾的富豪 |

      使用过滤器时，列表中过滤器函数的第一个参数表示被过滤的变量（value）或字符串（s)，即竖线符号左侧的值，其他的参数可以通过括号传入。另外，过滤器可以链式使用，如下：
  
      ```html
      <h1>Hello, {{ name | default('stranger') | title }}!</h1>
      ```

      根据Flask的设置，Jinja2会自动对模板中的变量进行转义，所以我们不用手动使用escape过滤器或调用escape()函数对变量进行转义。如果想避免转义，将变量作为HTML解析，可以对变量使用safe过滤器；另一种将文本标记为安全的方法是在渲染前将变量转换为Markup对象：
  
      ```html
      {{ sanitized_text | safe }}
      ```
  
      ```pyton
      from flask import Markup
      @app.route('/hello')
      def hello():
      	text = Markup('<h1>Hello Flask!</h1>')
      	return render_template('hello.html', text=text)
      ```

    - 自定义过滤器

      如果内置的过滤器不能满足需求，还可以添加自定义过滤器。使用`@app.template_filter()`装饰器可以注册自定义过滤器。如下：
  
      ```python
      from flask import Markup
      
      @app.template_filter()
      def musical(s):
        return s + Markup(' &#9835')
      ```

      可在@app.template_filter()中使用name关键字设置过滤器的名称，默认使用函数名称。过滤器需要接收被处理的值作为输入，返回处理后的值。

      也可以直接使用`app.add_template_filter()`方法注册自定义函数，传入函数对象和可选的自定义名称，如`app.add_template_filter('musical', name='Musical')`。
      
      

  - **测试器**

    在Jinja2中，测试器（Test）是一些用来测试变量或表达式，返回布尔值（True或False）的特殊函数。

    - 内置测试器
  
      Jinja2内置了许多测试器，常用的测试器及用法说明如下表：
  
      | 测试器               | 说明                                       |
      | -------------------- | ------------------------------------------ |
      | callale(object)      | 判断对象是否可被调用                       |
      | defined(value)       | 判断变量是否已被定义                       |
      | undefined(value)     | 判断变量是否未被定义                       |
      | none(value)          | 判断变量是否为None                         |
      | number(value)        | 判断变量是否为数字                         |
      | string(value)        | 判断变量是否为字符串                       |
      | sequence(value)      | 判断变量是否是序列，比如字符串、列表、元组 |
      | iterable(value)      | 判断变量是否可迭代                         |
      | mapping(value)       | 判断变量是否是匹配对象，比如字典           |
      | sameas(value, other) | 判断变量与other是否指向相同的内存地址      |
  
      使用测试器时，is的左边是测试器函数的第一个参数（value)，其他参数可以添加括号传入，也可以在右侧使用空格链接，以sameas为例：
  
      ```html
      {% if foo is sameas(bar) %}
      <!-- 等同于 -->
      {% if foo is sameas bar %}
      ```

    - 自定义测试器
  
      与过滤器类似，我们可以使用Flask提供的`@app.tempalte_test()`装饰器来注册一个自定义测试器。如下：
  
      ```pyton
      @app.template_test()
      def bar(z):
      	if n == 'baz':
      		return True
      	return False
      ```

      测试器的名称默认为函数名称，也可以在@app.template_test()中使用name关键字参数指定自定义名称。测试器函数需要接收被测试的值作为输入，返回布尔值。
  
      也可以直接使用`app.add_template_test()`方法注册自定义测试器，传入函数对象和可选的自定义名称（name)，比如`app.add_template_test('bar', name='Bar')`
  
      
  
- 模板环境变量

  在Jinja2中，渲染行为由jinja2.Environment类控制，所有的配置选项、上下文变量、全局函数、过滤器和测试器都存储在Environment实例上。当与Flask结合后，我们并不单独创建Environment对象，而是使用Flask创建的Environment对象，它存储在`app.jinja_env`属性上。

  在程序中，我们可以使用`app.jinja_env`更改Jinja2的设置。比如，自定义所有的定界符

  ```python
  app = Flask(__name__)
  app.jinja_nev.variable_start_string = '[['
  app.jinja_env.variable_end_string = ']]'
  ```

  模板环境中的全局函数、过滤器和测试器分别存储在Environment对象的globals、filters和tests属性中，这三个属性都是字典对象。除了使用Flask提供的装饰器和方法注册自定义函数，我们也可以直接操作者三个字典来添加相应的函数或变量，这通过向对应的字典属性中添加一个键值对实现，传入模板的名称作为建，对应的函数对象或变量作为值。

  - 添加自定义全局变量

    和app.template_global()装饰器不同，直接操作globals字典允许我们传入任何python对象，而不仅仅是函数，类似于上下文处理函数的作用。

    ```pyton
    def bar():
    	return 'I am bar.'
    foo = 'I am foo.'
    
    app.jinja_env.globals['bar'] = bar
    app.jinja_env.globals['foo'] = foo
    ```

  - 添加自定义过滤器

    使用app.jinja_env.filters向模板中添加自定义过滤器，如下：

    ```python
    def smiling(s):
      return s + ':)'
    app.jinja_env.filters['smiling'] = smiling
    ```

  - 添加自定义测试器

    使用app.jinja_env.tests向模板中添加自定义测试器，如下：

    ```python
    def baz(n):
      if n == 'baz':
        return True
      return False
    app.jinja_env.tests['baz'] = baz
    ```

    

# 模板结构组织

除了使用函数、过滤器等工具控制模板的输出外，Jinja2还提供了一些工具来在宏观上组织模板内容。借助这些技术，我们可以更好地实践DRY(Don't repeat yourself）原则。

- 局部模板

  在Web程序中，我们通常会为每一类页面编写一个独立的模板，如主页模板、用户资料页模板等，这些模板可以直接在视图函数中渲染并作为HTML响应主体。除了这类模板，我们还会用到另一类非独立模板，这类模板通常被称为**局部模板或次模板**，因为它们仅包含部分代码，所以我们不会在视图函数中直接渲染它，而是插入到其他独立模板中。

  当多个独立模板中都会使用同一块HTML代码时，我们就可以把这部分代码抽离出来，存储到局部模板中。这样一方面可以避免重复，另一方面也可以方便统一管理。

  我们使用include标签来插入一个局部模板，这会把局部模板的全部内容插在使用include标签的位置。为了和普通模板分开，局部模板的命名通常以一个下划线开始，如`_banner.html`

  ```html
  {% include '_banner.html' %}
  ```

  

- 宏

  宏（macro）是Jinja2提供的一个非常有用的特性，类似于python中的函数。使用宏可以把一部分模板代码封装到宏里，使用传递的参数来构建内容，最后返回构建后的内容。在功能上，它和局部模板类似，都是为了方便代码块的重用。

  通常把宏存储于单独的文件中，命名为`macros.html`或`_macros.html`。在创建宏时，使用macro和endmacro标签声明宏的开始和解书。在开始标签中定义宏的名称和接收的参数，如下：

  ```html
  {% macro qux(amount=1) %}
  	{% if amount == 1 %}
  		I am qux.
  	{% elif amount > 1 %}
  		We are quxs.
  	{% endif %}
  {% endmacro %}
  ```

  使用时，需要使用import语句导入它，然后作为函数调用，传入必要的参数，如下：

  ```html
  {% from '_macros.html' import qux %}
  ...
  {{ qux(amount=5) }}
  ```

  在Jinja2中，处于性能的考虑，并且为了让这一切保持显式，默认情况下包含（include)一个局部模板会传递当前上下文到局部模板中，但导入（import）却不会。具体来说，当我们使用render_template()函数渲染一个foo.html模板时，这个foo.html的模板上下文中包含下列对象：

  1. Flask使用内置的模板上下文处理函数提供的g、session、config、request；
  2. 扩展使用内置的模板上下文处理函数提供的变量；
  3. 自定义模板上下文处理器传入的变量；
  4. 使用render_template()函数传入的变量；
  5. Jinja2和Flask内置及自定义全局对象
  6. Jinja2内置及自定义过滤器；
  7. Jinja2内置及自定义测试器

  使用include标签插入的举报模板同样可以使用上述上下文中的变量和函数。而导入另一个并非被直接渲染的模板时，这个模板仅包含下列这些对象：

  1. Jinja2和Flask内置的全局函数和自定义全局函数；
  2. Jinja2内置及自定义过滤器；
  3. Jinja2内置及自定义测试器

  因此，如果我们想要在导入的宏中使用第一个列表中的2、3、4项，就需要在导入时显示地使用with context声明传入当前模板的上下文：

  ```html
  {% from '_macros.html' import foo with context %}
  ```

  虽然Flask使用内置的模板上下文处理函数传入session、g、request和config，但它同时也使用app.jinja_env.globals字典将这几个变量设置为全局变量，所以我们仍然可以在不显示声明传入上下文的情况下，直接在导入的宏中使用它们。

- 模板继承

  Jinja2的模板继承允许你定义一个基模板，把网页上的导航栏、页脚等通用内容放在基模板中，而每一个继承基模板的子模板在被渲染时都会自动包含这些部分。使用这种方式可以避免在多个模板中编写重复的代码。

  - 编写基模板

    基模板存储了程序页面的固定部分，通常被命名为base.html或layout.html。当子模板继承基模板后，子模板会自动包含基模板的内容和结构。为了能够让子模板方便地覆盖或插入内容到基模板中，我们需要在基模板中定义块（block），在子模板中可以通过定义同名块来执行继承操作。

    块的开始和结束分别使用block和endblock标签声明，而且块之间可以嵌套。块的名称可以随意指定，而且不是必须的。为了避免混乱，快的结束标签可以指定块名，同时要确保前后名称一致。

    ```html
    <head>
      {% block head %}
      	<meta charset="utf-8">
      	<title>{% block title %}Template - HelloFlask{% endblock %}</title>
      {% endblock %}
    </head>
    ```

    模板继承示意图：

    <img src="https://i.loli.net/2021/09/09/gmTS2CvA9h1FL8w.png" alt="image.png" style="zoom:80%;" />

  - 编写子模板

    因为基模板中定义了HTML的基本机构，而且包含了页脚等固定信息，在子模板中我们不再需要定义这些内容，只需要对特定的块进行修改。

    我们使用extends标签声明扩展基模板 (extends必须是子模板的第一个标签)，它告诉模板引擎当前模板派生自base.html，如下：

    ```html
    {% extends 'base.html' %}
    ```

    在子模板中，我们可以对父模板中的块执行两种操作：

    1. 覆盖内容：当在子模板中创建同名的块时，会使用子块的内容覆盖父块的内容。
    2. 追加内容：如果想要向基模板中的块追加内容，需要使用Jinja2提供的super()函数进行声明，这会向父块添加内容。

    当子模板被渲染时，它会继承基模板中的所有内容，然后根据我们定义的块进行覆盖或追加操作。



# 模板进阶

- 加载静态文件

  一个Web项目不仅需要HTML模板，还需要许多静态文件，比如CSS、JavaScript文件、图片以及音频等。在Flask程序中，默认要将静态文件存储在与主脚本（包含程序实例的脚本）同级目录的static文件夹中。

  为了在HTML中引用静态文件，我们需要使用url_for()函数获取静态文件的URL。**Flask内置了用于获取静态文件的视图函数，端点值为static，它的默认URL规则为/static/<path: filename>， URL变量filename是相对于static文件夹根目录的文件路径。**

  ```html
  <img src="{{ url_for('static', filename='avatar.jpg') }}" width=50>
  ```

  如果想使用其他文件夹来存储静态文件，可以在实例化Flask类时使用`static_folder`参数指定，静态文件的URL路径中的static也会自动跟随文件夹名称变化。在实例化Flask类时，使用`static_url_path`参数则可以自定义静态文件的URL路径。

  - 添加Favicon

    在启动程序运行后，我们经常在命令行看到一条404状态的get请求，请求的URL为`/favicon.ico`，如下:

    ```bash
    127.0.0.1 - - [09/Sep/2021 16:36:11] "GET /favicon.ico HTTP/1.1" 404 -
    ```

    favicon.ico文件指的是Favicon（favorite icon），又称shortcut icon、tab icon、website icon或者bookmark icon。顾名思义，这是一个在浏览器标签页、地址栏和书签收藏夹等处显示的小图标，作为网站的特殊标记。浏览器在发起请求时，会自动向根目录请求这个文件，当没有提供这个文件时，就会产生404错误。这个文件一般是一个宽高相同的ICO格式文件，命名为favicon.ico。除了ICO格式外，png和gif格式也被所有主流浏览器支持。

    为了正确返回Favicon，可以显示的在HTML页面中声明Favicon的路径，如下：

    ```html
    <link rel="icon" type="image/x-icon" href="{{ url_for('static', filename='favicon.ico') }}" >
    ```

  - 使用css框架

    在编写Web程序时，手动编写CSS比较麻烦，更常见的做法是使用 CSS框架来为程序添加样式。CSS框架内置了大量可以直接使用的CSS 样式类和JavaScript函数，使用它们可以非常快速地让程序页面变得美观 和易用，同时我们也可以定义自己的CSS文件来进行补充和调整。

  - 使用宏加载静态资源

    为了方便加载静态资源，可以创建一个专门用于加载静态资源的宏，如下：

    ```html
    {% macro static_file(type, filename_or_url, local=True) %}
    	{% if local %}
    		{% set filename_or_url = url_for('static', filename=filename_or_url) %}
    	{% endif %}
    	{% if type="css" %}
    		<link rel="stylesheet" href="{{ filename_or_url }}" type="text/css">
    	{% elif type="js" %}
    		<script type="text/javascript" src="{{ filename_or_url }}"></script>
    	{% elif type="icon" %}
    		<link rel="icon" href="{{ filename_or_url }}">
    	{% endif %}	
    {% endmacro %}
    ```

    在模板中导入宏后，只需要在调用时传入静态资源的类别和文件路径就会获得完整的资源加载语句。如下：

    ```html
    static_file('css', 'css/bootstrap.min.css')
    ```

    或从CDN加载资源

    ```html
    static_file('css', 'https://maxcdn.../css/bootstrap.min.css', local=False)
    ```

    

- 消息闪现

  Flask提供了一个非常有用的flash()函数，它可以用来闪现需要显示给用户的消息，比如当用户登录成功后显示“欢迎回来！”。**在视图函数调用flash()函数传入消息内容，消息会存储在session对象中，我们需要再模板中使用全局函数get_flashed_messages()来获取消息并将其展示出来。**

  > 通过flash()函数发送的消息会存储在session对象中，所以我们需要为程序设置秘钥。可以通过app.secret_key属性或配置变量SECRET_KEY设置。

  Flask提供了get_flashed_messages()函数用来在模板里获取消息。当get_flashed_messages()函数被调用时，session中存储的所有消息都会被移除。

  

- 自定义错误页面

  当程序返回错误响应时，会渲染一个默认的错误页面，但可能与其他页面的风格不符。我们可以注册错误处理函数来自定义错误页面。

  错误处理函数和视图函数很相似，返回值将会作为响应的主体，因此我们先要创建错误页面的模板文件。为了和普通模板区分开来，我们可以在模板文件夹templates里为错误页面创建一个errors子文件夹，存放不同错误吗对应的模板文件。

  错误处理函数需要附加`@app.errorhandler()`装饰器，并传入错误状态码作为参数。错误处理函数本身则需要接收异常类作为参数，并在返回值中注明对应的HTTP状态码。当发生错误时，对应的错误处理函数会被调用，它的返回值会作为错误响应的主体，如下：

  ```python
  from flask import Flask, render_template
  ...
  @app.errorhandler(404)
  def page_not_fount(e):
    return render_template('errors/404.html'), 404
  ```

  Flask通过抛出Werkzeug中定义的HTTP异常类来表示HTTP错误，错误处理函数接收的参数就是这些异常类对象。内置的异常对象提供了下列常用属性，如下表：

  | 属性        | 说明                                                         |
  | ----------- | ------------------------------------------------------------ |
  | code        | 状态码                                                       |
  | name        | 原因短语                                                     |
  | description | 错误描述，另外使用get_description()方法还可以获取HTML格式的错误描述代码 |

  

- JavaScript和CSS中的Jinja2

  当程序逐渐变大时，很多时候我们会需要在javascript和css代码中使用jinja2提供的变量值，甚至是控制语句。但是只有使用render_template()传入的模板文件才会被渲染，如果你把Jinja2代码写在单独的javascript或css文件中，尽管在html文件中引入了它们，它们中的jinja2代码永远也不会被执行。这时候，我们可以把想要获取的数据，定义为javascript/css变量。

  - javascript变量

    1. 元素特定的数据

       对于想要在javascript中获取数据，如果是元素特定的数据， 比如某篇文章对应的id，可以通过html元素的`data-*`属性存储，如：

       ```html
       <span data-id="{{ user.id }}" data-username="{{ user.username }}">{{ user.username }}</span>
       ```

       在javascript中我们可以使用DOM元素的`dataset`属性获取`data-*`属性值，如`element.dataset.username`，或是使用getAttribute()方法，如`element.getAttribute('data-username')`；使用jQuery时，可以直接对jQuery对象调用data方法获取，比如`$element.data('username')`。

       > 在html中，data-*被称为自定义数据属性（custom data attribute），我们可用它来存储自定义的数据供ls获取。

    2. 全局需要使用的数据

       对于全局需要使用的数据，则可以再页面中使用嵌入式javascript定义边浪，如果无法定义为javascript变量，那就考虑定义为函数，如：

       ```html
       <script type="text/javascript">
         var foo = '{{ foo_variable }}'
       </script>
       ```

  - css变量

    有时候我们会需要将jinja2变量值传入css文件，比如我们希望将用户设置的主题颜色设置到对应的css规则中，或是需要将static目录下某个图片的url传入css来设置为背景图片，除了将这部分css定义直接写在html中外，我们可以将这些值定义为css变量，如：

    ```html
    <style>
      :root {
        -- theme-color: {{ theme_color }};
        -- background-url: {{ url_for('static', filename='background.jpg') }}
      }
    </style>
    ```

    在css文件中，使用var()函数并传入变量名即可获取对应的变量值：

    ```css
    #foo {
      color: var(--theme-color)
    }
    #bar {
      background
    }
    ```



# 使用Flask-WTF处理表单

在html中，表单通过`<form>`标签创建，表单中的字段使用`<input>`标签定义。在表单中，我们创建`<input>`标签表示各种输入字段，`<label>`标签则用来定义字段的标签文字。我们可以`<form>`、`<input>`标签中使用各种属性来对表单进行设置。

WTForms支持在python中使用类定义表单，然后直接通过类定义生成对应的html代码，这种方式更加方便，而且使表单更易于重用。

扩展Flask-WTF集成了WTForms，使用它可以在Flask中更方便地使用WTForms。Flask-WTF将表单数据解析、CSRF保护、文件上传等功能与Flask继承，另外还附加了reCAPTCHA支持。

> reCAPTCHA是google开发的免费验证码服务

Flask-WTF默认为每个表单启用CSRF保护，它会为我们自动生成和验证CSRF令牌。默认情况下，Flask-WTF使用程序秘钥来对CSRF令牌进行签名，因此要进行秘钥设置：

```python
app.secret_key = 'xxxx'
```

- 定义WTForms表单类

  当使用WTForms创建表单时，表单由python类表示，这个类继承从WTForms导入的Form基类。一个表单由若干个输入字段组成，这些字段分别用表单类的类属性来表示（字段即Field，可以理解为表单内的输入框、按钮等部件）。 

  ```python
  from wtforms import Form, StringField, PasswordFiele, BooleanField, SubmitField
  from wtforms.validators import DataRequired, Length
  
  class LoginForm(Form):
      username = StringField('Username', validators=[Datarequired()])
      password = PasswordField('Password', validators=[Datarequired(), Length(8, 128)])
      remember = BooleanField('Remember me')
      submit = SubmitField('Log in')
  ```

  **每个字段属性通过实例化WTForms提供的字段类表示。字段属性的名称将作为对应HTML`<input>`元素的name属性及id属性值。**字段属性名称大小写敏感，不能以下划线或validate开头。有些字段最终生成的HTML相同，不过WTForms会在表单提交后根据表单中字段的类型对数据进行处理，转换成对应的Python类型，以便在Python脚本中对数据进行处理。常见的WTForms字段如下表：

  | 字段类              | 说明                                        | 对应的HTML表示                                |
  | ------------------- | ------------------------------------------- | --------------------------------------------- |
  | BooleanField        | 复选框，值会被处理为True或False             | `<input type="checkbox">`                     |
  | DateField           | 文本字段，值会被处理成datetime.date对象     | `<input type="text">`                         |
  | DateTimeField       | 文本字段，值会被处理成datetime.datetime对象 | `<input type="text">`                         |
  | FileField           | 文件上传字段                                | `<input type="file">`                         |
  | FloatField          | 浮点数字段，值会被处理为浮点型              | `<input type="text">`                         |
  | IntegerField        | 整数字段，值会被处理为整数                  | `<input type="text">`                         |
  | RadioField          | 一组单选按钮                                | `<input type="radio">`                        |
  | SelectField         | 下拉列表                                    | `<select><option></option></select>`          |
  | SelectMultipleField | 多选下拉列表                                | `<select multiple><option></option></select>` |
  | SubmitField         | 提交按钮                                    | `<input type="submit">`                       |
  | StringField         | 文本字段                                    | `<input type="text">`                         |
  | HiddenField         | 隐藏文本字段                                | `<input type="hidden">`                       |
  | PasswordField       | 密码文本字段                                | `<input type="password">`                     |
  | TextAreaField       | 多行文本字段                                | `<textarea></textarea>`                       |

  通过实例化字段类时传入的参数，我们可以对字段进行设置，字段类构造方法接收的常用参数如下表：

  | 参数       | 说明                                                         |
  | ---------- | ------------------------------------------------------------ |
  | label      | 字段标签`<babel>`的值，也就是渲染后显示在输入字段前的文字    |
  | render_kw  | 一个字典，用来设置对应的HTML` <input>`标签的属性，比如传入{'placeholder': 'Your name'}，渲染后的HTML代码会将`<input>`标签的placeholder属性设置为Your name |
  | validators | 一个列表，包含一系列验证器，会在表单提交后被逐一调用验证表单数据 |
  | default    | 字符串或可调用对象，用来为表单字段设置默认值                 |

  在WTForms中，验证器（validator)是一系列用于验证字段数据的类，我们在实例化字段类时使用validators关键字来指定附加的验证器列表。验证器从wtforms.validators模板中导入，常用的验证器如下表：

  | 验证器                                              | 说明                               |
  | --------------------------------------------------- | ---------------------------------- |
  | DataRequired(message=None)                          | 验证数据是否有效                   |
  | Email(message=None)                                 | 验证Email地址                      |
  | EqualTo(fieldname, message=None)                    | 验证两个字段是否相同               |
  | InputRequired(message=None)                         | 验证是否有数据                     |
  | Length(min=1, max=1, message=None)                  | 验证输入值的长度是否在给定的范围内 |
  | NumberRange(min=None, max=None, message=None）      | 验证输入数字是否在给定范围内       |
  | Optional(strip_whitespace=True)                     | 允许输入值为空，并跳过其他验证     |
  | Regexp(regex, flag=0, message=None)                 | 使用正则表达式验证输入值           |
  | URL(required_tld=True,  message=None)               | 验证URL                            |
  | AnyOf(values, message=None, values_formatter=None)  | 确保输入值在可选值列表中           |
  | NoneOf(values, message=None, values_formatter=None) | 确保输入值不在可选值列表中         |

  在实例化验证类时，message参数用来传入自定义错误消息，如果没有设置则使用内置的英文错误消息。

  当使用Flask-WTF定义表单时，我们仍然使用WTForms提供的字段类和验证器，创建的方式也完全相同，只不过表单类要继承Flask-WTF提供的FlaskForm类。FlaskForm类继承自Form类，进行了一些设置，并附加了一些辅助方法，以便与Flask集成。

  ```python
  from flask_wtf import FlaskForm
  ...
  class LoginForm(FlaskForm):
    ...
  ```

  

-  输出HTML代码

  实例化表单类。然后将实例属性转化为字符串或直接调用就可以获取表单字段对应的HTML代码：

  ```python
  >>> form = LoginForm()
  >>> form.username()
  Markup('<input id="username" name="username" required type="text" value="">')
  >>> form.username.label()
  (Markup('<label for="username">Username</label>')
  ```

  在创建HTML表单时，我们会需要使用input元素的其他属性值对字段进行设置，如添加class属性、placeholder属性。WTForms输出的字段HTML代码只会包含id和name属性，属性值均为表单类中对应的字段属性名称。如果要添加额外的属性，通常有两种方法：

  1. 使用render_kw属性

     为username字段使用render_kw设置placeholder属性：

     ```python
     username = StringField('Username', render_kw={'placeholder': 'Your name'})
     ```

     这个字段被调用后输出的html代码如下：

     ```python
     Markup('<input id="username" name="username" placeholder="Your name" required type="text" value="">')
     ```

  2. 在调用字段时传入

     在调用字段属性时，通过添加括号使用关键字参数的形式也可以传入字段额外的html属性：

     ```python
     >>> form.username(style='width: 200px', class_='bar')
     Markup('<input class="bar" id="username" name="username" required style="width: 200px" type="text" value="">')
     ```

     > `class`是python中的保留关键字，所以需要使用`class_`来代替`class`，渲染后的`<input>`会获得正确的`class`属性，在模板中调用时则可以直接使用`class`。

  

- 在模板中渲染表单

  为了能够在模板中渲染表单，我们需要把表单类实例传入模板。首先在视图函数里实例化表单类LoginForm，然后在render_template()函数中使用关键字参数form将表单实例传入模板，如下：

  ```python
  from forms import LoginForm
  
  @app.route('/basic')
  def basic():
    form = LoginForm()
    return render_template('login.html', form=form)
  ```

  在模板中，只需要调用表单类的属性即可获取字段对应的html代码，如果需要传入参数，也可添加括号，如下：

  ```html
  <form method="post">
    {{ form.csrf_token }}
    {{ form.username.label }}{{ form.username }}<br>
    {{ form.password.label }}{{ form.password }}<br>
    {{ form.remember }}{{ form.remember.label }}<br>
    {{ form.submit }}
  </form>
  ```

  > 📢：除了渲染各个字段的标签和字段本身，我们还调用了`from.csrf_token`属性渲染Flask-WTF为表单类自动创建的CSRF令牌。form.csrf_token字段包含了自动生成的CSRF令牌，在提交表单后会自动被验证，为了确保表单通过验证，我们必须在表单中手动渲染这个值。

  Flask-WTF为表单类实例提供了一个`form.hidden_tag()`方法，这个方法会依次渲染表单中所有的隐藏字段。因为csrf_token字段也是隐藏字段，所以当这个方法被调用时也会渲染csrf_token字段。
  
  

# 处理表单数据

表单数据的处理涉及很多内容，除去表单提交不说，从获取数据到保存数据大致会经历以下步骤：

1. 解析请求，获取表单数据；
2. 对数据进行必要的转换，比如将勾选框的值转换成python的布尔值；
3. 验证数据是否符合要求，同时验证CSRF令牌；
4. 如果验证未通过则需要生成错误消息，并在模板中显示错误消息；
5. 如果验证通过，就把数据保存到数据库或做进一步处理。

使用Flask-WTF和WTFroms可以极大得简化这些步骤。

- 提交表单

  在HTML中，当`<form>`标签声明的表单中类型为submit的提交字段被单击时，就会创建一个提交表单的http请求，请求中包含表单各个字段的数据。表单的提交行为主要由三个属性控制，如下表：

  | 属性    | 默认值                            | 说明                                                         |
  | ------- | --------------------------------- | ------------------------------------------------------------ |
  | action  | 当前URL，即页面对应的URL          | 表单提交时发送请求的目标URL                                  |
  | method  | get                               | 提交表单的http请求方法，目前仅支持get、post                  |
  | enctype | application/x-www-form-urlencoded | 表单数据的编码类型，当表单中包含文件上传字段时，需要设为mulitipart/form-data，还可以设为纯文本类型text/plain |

  form标签的action属性用来指定表单被提交的目标URL，默认为当前URL，也就是渲染该模板的路由所在的URL。如果想要把表单数据发送到其他URL，可以自定义这个属性值。

  当使用GET方法提交表单数据时，表单数据会以查询字符串的形式附加在请求的URL里，如：

  ```
  http://localhost:5000/basic?username=greyli&password=12345
  ```

  GET方法仅适用于长度不超过3000个字符，且不包含敏感信息的表单。因为这种方式会直接将用户提交的表单数据暴露在URL中，容易被攻击者截获。处于安全考虑，一般使用POST方法提交表单。使用POST方法时，按照默认的编码类型，表单数据会被存储在请求主体中。

  因为Flask为路由设置默认监听的http方法为GET，为了支持接收表单提交发送的POST请求，我们必须在app.route()装饰器里使用methods关键字为路由指定http防范，如下：

  ```python
  @app.route('/', methods=['GET', 'POST'])
  def basic():
    form = LoginForm()
    return render_template('login.html', form=form)
  ```

  

- 验证表单数据

  1. 客户端验证和服务器端验证

     表单验证通过分为一下两种形式:

     - 客户端验证（client side validation）：是指在客户端对用户的输入值进行验证。可以使用HTML5内置的验证属性来实现基本的客户端验证（type、requeired、min、max、accept等），另外可以使用javascript实现完善的验证机制。客户端方式可以实时动态提示用户输入是否正确，只有用户输入正确后才会将表单数据发送到服务器。客户端验证可以增强用户体验，降低服务器负载。
     - 服务端验证（server side validation）：是指用户把输入的数据提交到服务器，在服务器端对数据进行验证。如果验证出错，就在返回的响应中加入错误信息。用户修改后再次提交表单，知道通过验证。我们在Flask程序中使用WTForms实现的就是服务器端验证。

  2. WTForms验证机制

     WTFroms验证表单字段的方式是在实例化表单类时传入表单数据，然后对表单实例调用validate()方法。这会逐个对字段调用字段实例化时定义的验证器，返回表示验证结果的布尔值。如果验证失败，就把错误消息存储到表单实例的errors属性对应的字典中。

     ```shell
     >>> form = LoginForm(username='', passworf='123', remember=True)
     >>> form.data # 表单数据字典
     {'username': '', 'password': '123', 'remember': True, 'submit': False, 'csrf_token': None}
     >>> form.validate()
     False
     >>> form.errors # 错误消息字典
     {'username': ['This field is required.'], 'password': ['Field must be between 8 and 128 characters long.'], 'csrf_token': ['The CSRF token is missing.']}
     ```

     使用POST方法提交的表单，其数据会被Flask解析为一个字典，可以通过请求对象的form属性获取（`request.form`)；使用GET方法提交的表单数据同样会被解析为字典，不过要通过请求对象的args属性获取（`request.args`）。

  3. 在视图函数中验证表单
  
     目前basic视图函数同时接收两种类型的请求：GET请求和POST请求。所以我们需要根据请求方法的不同执行不同的代码。即：首先实例化表单，如果是GET请求，那么就渲染模板；如果是POST请求，就调用validate()方法验证表单数据。
  
     请求的HTTP方法可以通过request.method属性获取，具体如下：
  
     ```python
     from flask import request
     ...
     @app.route('/basic', methods=['GET', 'POST'])
     def basic():
       form = LoginForm()
       if request.method == 'POST' and form.validate():
         ... # 处理post请求
       return render_template('login.html', form=form)
     ```
  
     当请求方法是GET时，会跳过这个if语句，渲染login.html模板；当请求方法是POST(说明用户提交了表单)时，则验证表单数据。这会逐个字段（包括CSRF令牌字段）调用附加的验证器进行验证。
  
     > 因为WTForms会自动对CSRF令牌字段进行验证，如果没有渲染该字段会导致验证出错，错误消息为“CSRF token is missing”。
  
     Flask-WTF提供的validate_on_submit()方法合并了这两个操作，因此上面的代码可以简化为：
  
     ```python
     from flask import request
     ...
     @app.route('/basic', methods=['GET', 'POST'])
     def basic():
       form = LoginForm()
       if form.validate_on_submit():
         ...
       return render_template('login.html', form=form)
     ```
  
     如果validate_on_submit()返回True，则表示用户提交了表单，且表单通过验证，name我们就可以在这个if语句中获取表单数据：
  
     ```python
     from flask import request
     ...
     @app.route('/basic', methods=['GET', 'POST'])
     def basic():
       form = LoginForm()
       if form.validate_on_submit():
         username = form.username.data
         flash('welcome home,%s' % username)
         return redirect(url_for('index'))
       return render_template('login.html', form=form)
     ```
  
     表单类的data属性时一个匹配所有字段与对应数据的字典，我们一般直接通过`form.字段属性名.data`的形式来获取对应字段的数据。
  
     > 在if语句中，如果不使用重定向的话，当if语句执行完毕后会继续执行最后的render_template()函数渲染模板，最后像往常一样返回一个常规的200响应，但这会造成一个问题：
     >
     > 在浏览器中，当单击F5刷新/重载时的默认行为是发送上一个请求。如果上一个请求是Post请求，俺么就会弹出一个确认窗口，询问用户是否再次提交表单。为了避免出现这个让人困惑的提示，我们进行不要让提交表单的POST请求作为最后一个请求。这就是为什么我们在处理表单后返回一个重定向响应，这会让浏览器重新发送一个新的GET请求到重定向的目标URL。最终，最后一个请求就变成了GET请求。这种用来防止重复提交表单的技术称为PRG(Post/Redirect/Get)模式，即通过对提交表单的POST请求返回重定向响应将最后一个请求转换为GET请求。
  
  
  
- 在模板中渲染错误消息

  如果form.validate_on_submit()返回False，那么说明验证没有通过。对于验证未通过的字段，WTForms会把错误消息添加到表单类的errors属性中，这是一个匹配作为表单字段的类属性到对应的错误消息列表的字典。我么一般会直接通过字段名来获取对应字段的错误消息列表，即`form.字段名.errors`。我们可以在模板中使用for循环迭代错误消息列表，如下：
  
  ```html
  {% for message in form.password.errors %}
  	{{ message }}
  {% endfor %}
  ```
  
- 总结：

  表单处理流程图如下所示：

  <img src="https://i.loli.net/2021/09/13/fUHbVcX7pZnhOys.png" alt="image.png" style="zoom: 50%;" />



# 表单进阶

- SelectField类表示`<select>`标签

  用于创建文章的表单PostForm实现如下：

  ```python
  class PostForm(FlaskForm):
      title = StringField('Title', validators=[DataRequired(), Length(1, 60)])
      category = SelectField('Category', coerce=int, default=1)
      body = CKEditorField('Body', validators=[DataRequired()])
      submit = SubmitField()
  
      def __init__(self, *args, **kwargs):
          super(PostForm, self).__init__(*args, **kwargs)
          self.category.choices = [(category.id, category.name) for category in Category.query.order_by(Category.name).all()]
  ```

  文章创建表单由标题字段title、分类选择字段category、正文字段body和提交按钮组成，其中正文字段使用Flask-CKEditor提供的CKEditorField字段。

  下拉列表字段使用WTForms提供的SelectField类来表示html中的`<select>`标签，如：

  ```html
  <select>
    <option value ="1">Python</option>
    <option value ="2">Jave</option>
    <option value="3">C++</option>
  </select>
  ```

  下拉列表的选项 (即`<option>`标签)通过参数choices指定。choices是一个包含两元素元组列表，列表中的元组分别包含选项值选项标签 (如上面的 `[('1', 'Python'), ('2', 'Java'), ('3', 'C++')]` )。我们使用分类标签id作为选项值，分类标签名称作为选项标签，这两个值通过迭代`Category.query.order_by(Category.name).all()`返回的分类记录实例实现。选项值默认为字符串类型，我们使用`coerce`关键字指定数据类型为整型。default用于设置默认的选项值，我们将其指定为1，即默认分类的id。

  因为Flask-SQLAlchemy依赖于程序上下文才能正常工作（内部使用current_app获取配置信息)，所以这个查询调佣要放到构造方法中执行，在构造方法中对self.category.choices赋值的效果和在表单类中实例化SelectField类并设置choices参数相同。

  

- 使用宏渲染表单

  在模板中渲染表单时，往往有大量的工作要做：

  1. 调用字段属性，获取`<input>`定义；
  2. 调用对应的label属性，获取`<label>`定义；
  3. 渲染错误消息。

  为了避免为每一个字段重复这些代码，我们可以创建一个宏来渲染表单字段，如下：

  ```html
  {% macro form_field(field) %}
  	{{ field.label }}<br>
  	{{ field(**kwargs) }}<br>
  	{% if field.errors %}
  		{% for error in field.errors %}
  			<small class="error">{{ error }}</small>
  	{% endif %}
  {% endmacro %}
  ```

  form_field()宏接收表单类实例的字段属性和附加的关键字参数作为输入，返回包含`<label>`标签、表单字段、错误消息列表的html表单字段代码。使用这个宏渲染表单的示例如下：

  ```html
  {% from 'marcos.html' import form_field %}
  <form method="post">
    {{ form.csrf_tokeb }}
  	{{ form_field(form.username) }}<br>
    {{ form_field(form.password) }}<br>
    ...
  </form>
  ```

  我们调用form_field()宏逐个渲染表单中的字段，只要把每一个类属性传入form_field()宏，即可完成渲染。

- 自定义验证器

  1. 行内验证器

     除了使用WTForm提供的验证器来验证表单字段，我们还可以在表单类中定义方法来验证特定字段，如下：

     ```python
     from wtforms import IntegerField, SubmitField
     from wtfomrs.validators import ValidatorError
     
     class FortyTwoForm(FlaskForm):
       answer = IntegerField('The Number')
       submit = SubmitField()
       
       def validate_answer(form, field):
         if field.data != 42:
           raise ValidationError('Must be 42.')
     ```

     当表单类中包含以`validate_字段属性名`形式命名的方法时，在验证字段数据时会同时调佣这个方法验证对应的字段，这也是为什么表单类的字段属性名不能以validate开头。验证方法接收两个位置参数，依次为form和field，前者为表单类实例，后者是字段对象，我们可以通过field.data获取字段数据，这两个参数将在验证表单时被调用传入。验证出错时抛出从wtfoms.validators模块导入的ValidationError异常，传入错误消息作为参数。因为这种方法仅用来验证特定的表单类字段，所以又称为行内验证器（in-line validator）。

  2. 全局验证器

     如果想要创建一个可重用的通用验证器，可以通过定义一个函数实现。如果不需要传入参数定义验证器，那么一个和表单类中定义的验证方法完全相同的函数就足够了，如下：

     ```python
     from wtfoms.validators import ValidationError
     
     def is_42(form, field):
     	if field.data != 42:
     		raise ValidationError('Must be 42.')
     
     class FortyTwoForm(FlaskForm):
       answer = IntegerField('The Number', validators=[is_42])
       submit = SubmitField()
     ```

     当使用函数定义全局的验证器时，我们需要再定义字段时在validators列表里传入这个验证器。因为在validators列表中传入的验证器必须是可调用对象，所以这里传入了函数对象，而不是函数调用。

     通常我们需要让验证器支持传入参数来对验证过程进行设置。至少，应该支持message参数来设置自定义错误消息。这是验证函数应该实现成工厂函数，即返回一个可调用对象的函数，如下：

     ```python
     from wtforms.validators import ValidationError
     
     def is_42(message=None):
       if message is None:
         message = 'Must be 42.'
       def _is_42(form, field):
         if field.data != 42:
           raise ValidationError(message)
         return _is_42
      
     class FortyTwoForm(FlaskForm):
        answer = IntegerField('The Number', validators=[is_42()])
        submit = SubmitField()
     ```

     在现在的is_42()函数中，我们创建了另一个`_is_42()`函数，这个函数会被作为可调用对象返回。is_42()函数接收的message参数用来传入自定义错误消息，默认为None，如果没有设置就使用内置消息。在validators列表中，这时需要传入的是对工厂函数is_42()的调用。

     

- 文件上传

  在HTML中，渲染一个文件上传字段只需要将`<input>`标签的type属性设为file，即`<input type="file">`。这回在浏览器中渲染成一个文件上传字段，单击文件选择按钮会打开文件选择窗口，选择对应的文件后，被选择的文件名会显示在文件选择按钮的旁边。

  在服务器端，可以和普通数据一样获取上传文件数据并保存。不过我们需要考虑安全问题，文件上传漏洞也是比较流行的攻击方式。除了常规的CSRF防范，我们还需要重点注意下面的问题：

  - 验证文件类型；
  - 验证文件大小；
  - 过滤文件名

  1. 自定义上传表单

     在python表单类中创建文件上传字段时，我们使用扩展Flask-WTF提供的FileField类，它继承WTForms提供的上传字段FileField，添加了对Flask的集成，如下：

     ```python
     from flask_wtf.file import FileField, FileRequired, FileAllowed
     ...
     class UploadForm(FlaskForm):
         photo = FileField('Upload Image', validators=[FileRequired(), FileAllowed()])
         submit = SubmitField()
     ```

     与其他字段类似，我们也需要对文件上传字段进行验证。Flask-WTF在flask_wtf.file模块下提供了两个文件相关的验证器，如下表：

     | 验证器                                | 说明                                                         |
     | ------------------------------------- | ------------------------------------------------------------ |
     | FileRequired(message=None)            | 验证是否包含文件对象                                         |
     | FileAllowed(upload_set, message=None) | 用来验证文件类型，upload_set参数用来传入包含允许的文件后缀名列表 |

     > Flask-WTF提供的FileAllowed是在服务器端验证上传文件，使用HTML5中的accept属性也可以在客户端实现简单的类型过滤。这个属性接收MIME类型字符串或文件格式后缀，多个值之间使用逗号分隔，如下：
     >
     > ```html
     > <input type="file" id="profile_pic" name="profile_pic" accept=".jpg, .jpeg, .png, .gif">
     > ```
     >
     > 当用户单击文件选择按钮后，打开的文件选择窗口会默认将accept属性值之外的文件过滤掉。尽管瑞，用户还是可以选择设定之外的文件，所以我们仍然需要进行服务器端的验证。

     除了验证文件类型，我们通常还需要对文件大小进行验证。通过设置Flask内置的配置变量MAX_CONTENT_LENGTH，我们可以限制请求报文的最大长度，单位为字节（byte)，如下：

     ```python
     app.config['MAX_CONTENT_LENGTH'] = 3 * 1024 * 1024
     ```

  ​		当请求大小（上传文件大小）超过这个限制后，会返回413错误响应（Request entity too large)。

  2. 渲染上传表单

     在新创建的upload视图函数中，我们实例化UploadForm，然后传入模板：

     ```python
     @app.route('/upload', methods=['GET', 'POST'])
     def upload():
       form = UploadForm()
       ...
       return render_template('upload.html', form=form)
     ```

     在模板upload.html中渲染上传表单：

     ```html
     <form method="post" enctype="multipart/form-data">
       {{ form.csrf_token }}
       {{ form_field(form.photo) }}
       {{ form.submit }}
     </form>
     ```

     📢📢：当表单中包含文件上传字段（即type属性为file的input标签），需要将表单的enctype属性设为`mulitipart/form-data`，这会告诉浏览器将上传数据发送到服务器，否则仅会把文件名作为表单数据提交。

  3. 处理上传文件

     与普通的表单数据不同，当包含文件字段的表单提交后，上传的文件需要再请求对象的files属性（request.files)中获取。这个属性时Werkzeug提供的ImmutableMultiDict字典对象，存储字段的name键值和文件对象的映射，比如：

     ```python
     ImmutableMultiDict(['photo', <FileStorage: u'0f913b0ff95.JPG' ('image/jpeg')>])
     ```

     上传的文件会被Flask解析为Werkzeug中的FileStorage对象（werkzeug.datastructures.FileStorage）。当手动处理时，我们需要使用文件上传字段的name属性值作为键获取对应的文件对象，如：

     ```python
     request.files.get('photo')
     ```

     当使用Flask-WTF时，它会自动帮我们获取对应的文件对象，这里我们仍然使用表单类属性的data属性获取上传文件。处理上传表单提交请求的upload视图函数如下：

     ```python
     @app.route('/uplad', methods=['GET', 'POST'])
     def upload():
         form = UploadForm()
         if form.validate_on_submit():
             f = form.photo.data
             filename = random_filename(f.filename)
             f.save(os.path.join(app.config['UPLOAD_PATH'], filename))
             flash('Upload success')
             session['filename'] = [filename]
             return redirect(url_for('show_images'))
         return render_template('upload.html', form=form)
     ```

     当表单验证通过后，我们通过form.photo.data获取存储上传文件的FileStorage对象。接下来，我们需要处理文件名，通常有三种处理方式：

     - 使用原文件名：

       如果能够确定文件的来源安全，可以直接使用原文件名，通过FileStorage对象的filename属性获取：

       ```python
       filename = f.filename
       ```

     - 使用过滤后的文件名：

       如果要支持用户上传文件，我们必须对文件名进行处理，因为攻击者可能会在文件名中加入恶意路径，可以使用Werkzeug提供的secure_filename()函数对文件名进行过滤，传递文件名作为参数，它会过滤掉所有危险字符，返回安全的文件名，如下：

       ```shell
       >>> from werkzeug.utils import secure_filename
       >>> secure_filename('avatar!@#//#\\%$^&.jpg')
       'avatar_.jpg'
       >>> secure_filename('avatar头像.jpg')
       'avatar.jpg'
       ```

     - 统一重命名

       secure_filename()函数非常方便，它会过滤掉文件名中非ASCII字符。但如果文件名完全由非ASCII字符组成，那么会得到一个空文件名，如下：

       ```shell
       >>> secure_filename('头像.jpg')
       'jpg'
       ```

       为了避免这种情况，更好的做法是使用统一的处理方式对所有上传的文件重新明明。随机文件名有很多种方式生成，下面使用python内置的uuid模块生成随机文件名的random_filename()函数：

       ```python
       def random_filename(filename):
         ext = os.path.spliext(filename)[1]
         new_filename = uuid.uuid4().hex + ext
         return new_filename
       ```

       这个函数接收原文件名作为参数，使用内置的uuid模块中的uuid4()方法生成新的文件名，并使用hex属性获取十六进制字符串，最后返回包含后缀的新文件名。

       > UUID(Universally Unique Identifier，通用唯一识别码)是用来标识信息的128位数字，比如用作数据库表的主键。使用标准方法生成的UUID出现重复的可能性接近0。在UUID的标准中，UUID分为5个版本，每个版本使用不同的生成方法并且适用于不同的场景。uuid4()方法对应的是第4个版本：不接收参数而生成随机UUID。

       在upload视图中，我们低啊用这个函数来获取随机文件名，传入原文件名作为参数：

       ```python
       filename = random_filename(f.filename)
       ```

     处理完文件名后，是时候将文件保存到文件系统中了。在form目录下创建了一个uploads文件夹，用于保存上传后的文件。指向这个文件夹的绝对路径存储在自定义配置变量UPLOAD_PATH中：

     ```python
     app.config['UPLOAD_PATH'] = os.path.join(app.root_path, 'uploads')
     ```

     对FileStorage对象调用save()方法即可保存，传入包含目标文件夹绝对路径和文件名在内的完整保存路径：

     ```python
     f.save(os.path.join(app.config['UPLOAD_PATH'], filename))
     ```

     文件保存后，我们希望能够显示上传后的图片。为了让上传后的文件能够通过URL获取，还需要创建一个视图函数来返回上传后的文件，如下：

     ```python
     @app.route('/uploads/<path:filename')
     def get_file(filename):
       return send_from_directory(app.config['UPLOAD_PATH'], filename)
     ```

     这个视图的作用与Flask内置的static视图雷士，通过传入的文件路径返回对应的静态文件。在这个视图中，我们使用send_from_directory()函数来获取文件，传入文件的路径和文件名作为参数。

     在upload视图里保存文件后，我们使用flash()发送一个提示，将文件名保存到session中，最后重定向到show_images视图。show_images视图返回的uploaded.html模板中奖从session获取文件名，渲染出上传后的图片。

     ```python
     flash('Upload success')
     session['filenames'] = [filename]
     return redirect(url_for('show_images'))
     ```

     在uploaded.html模板里，我们将传入的文件名作为URL变量，通过上面的get_file视图获取文件URL，作为`<img>`标签的scr属性，如下所示：

     ```html
     <img src="{{ url_for('get_file'), filename=filename }}"
     ```

  4. 多文件上传

     在客户端，通过再文件上传字段(type=file)加入multiple属性，就可以开启多选：

     ```html
     <input type="file" id="file" name="file" multiple>
     ```

     创建表单类时，可以直接使用WTF提供的MultipleFileField字段实现，添加一个DataRequired验证器来确保包含文件：

     ```python
     from wtforms import MultipleFileField
     class MultiUploadForm(FlaskForm):
       photo = MultipleFileField('Upload Image', validators={DataRequired()})
       submit = SubmitField()
     ```

     表单提交时，在服务器端的程序中，对request.files属性调用getlist()方法并传入字段的name属性值会返回所有上传文件对象的列表。在multi_upload视图函数中，我们迭代这个列表，然后逐一对文件进行处理，如下：

     ```python
     @app.route('/multi-upload', methods=['GET', 'POST'])
     def multi_upload():
         form = MultiUploadForm()
         if request.method == 'POST':
             filenames = []
             try:
                 validate_csrf(form.csrf_token.data)
             except ValidationError:
                 flash('CSRF token error.')
                 return redirect(url_for('multi_upload'))
             if 'photo' not in request.files:
                 flash('This field is required.')
                 return redirect(url_for('multi_upload'))
             for f in request.files.getlist('photo'):
                 if f and allowed_file(f.filename):
                     filename = random_filename(filename)
                     f.save(os.path.join(app.config['UPLOAD_PATH'], filename))
                     filenames.append(filename)
                 else:
                     flash('Invalid file type.')
                     return redirect(url_for('multi_upload'))
             session['filenames'] = filenames
             return redirect(url_for('show_images'))
         return render_template('upload.html', form=form)
     ```

     在请求方法为POST时，我们对上传数据进行手动验证，主要包含下面几步：

     1. 手动调用flask_wtf.csrf.validate_csrf验证csrf令牌，传入表单中csrf_token隐藏字段的值。如果抛出ValidationError异常则表明验证未通过；

     2. 其中 if 'photo' not in request.files 用来确保字段中包含文件数据（相当于FileRequired验证器），如果用没有选择文件就提交表单则request.files将为空；

     3. if f用来确保文件对象存在，这里也可以检查f是否是FilesStorage实例；

     4. allowed_file(f.filename)调用了allowed_file()函数，传入文件名。这个函数相当于FileAllowed验证器，用来验证文件类型，返回布尔值，具体如下：

        ```python
        app.config['ALLOWED_EXTENSIONS'] = ['jpg', 'gif', 'png', 'jpeg']
        ...
        def allowed_file(filename):
            return '.' in filename and filename.rsplit('.', 1)[1].lower() in app.config['ALLOWED_EXTENSIONS']
        ```

        > 在上面几个验证语句里，如果没有通过验证，则使用flash()函数显示错误信息，然后重定向熬multi_upload()函数。

     5. 通过验证后保存上传后的文件名到session中，重定向到show_images()视图，这个视图返回的uploaded.html模板将从session获取所有文件名，渲染出所有上传后的图片。

        

- 使用Flask-CKEditor集成富文本编辑器

  富文本编辑器即WYSIWYG(What You See Is What You Get，所见即所得)编辑器，它提供一系列按钮和下拉列表来为文本设置格式，编辑状态的文本样式即最终呈现出来的样式。在web程序中，这种编辑器也成为html富文本编辑器，应为它使用html标签来为文本定义样式。

  CKEditor是一个开源的富文本编辑器，它包含丰富的配置选项，而且有大量第三方插件支持。扩展Flask-CKEditor简化了在Flask程序中使用CKEditor的过程，我们将使用它来集成CKEditor。

  首先进行安装：`pip install flask-ckeditor`，然后实例化Flask-CKEditor提供的CKEditor类，传入程序实例app：

  ```python
  from flask_ckeditor import CKEditor
  ckeditor = CKEditor(app)
  ```

  1. 配置富文本编辑器

     Flask-CKEditor提供了许多配置变量来对编辑器进行设置，常用的配置如下：

     | 配置键               | 默认值     | 说明                                          |
     | -------------------- | ---------- | --------------------------------------------- |
     | CKEDITOR_SERVE_LOCAL | False      | 设置为True会使用内置的本地资源                |
     | CKEDITOR_PKG_TYPE    | ‘standard’ | CKEditor包类型，可选值为basic、standard、full |
     | CKEDITOR_LANGUAGE    | ''         | 界面语言，传入ISO 639格式的语言码             |
     | CKEDITOR_HEIGHT      | ''         | 编辑器高度                                    |
     | CKEDITOR_WIDTH       | ''         | 编辑器宽度                                    |

     > 为了方便开发，我们使用本地资源：`app.config['CKEDITOR_SERVER_LOCAL'] = True`

  2. 渲染富文本编辑器

     富文本编辑器在html中通过文本区域字段表示，即`<textarea></textarea>`。Flask-CKEditor通过包装WTFroms提供的TextAreaField字段类型实现了一个CKEditorField字段类，我们使用它来构建富文本编辑框字段，如下：

     ```python
     from flask_ckeditor import CKEditorField
     ...
     class RichTextForm(FlaskForm):
         title = StringField('Title', validators=[DataRequired(), Length(1, 50)])
         body = CKEditorField('Body', validators=[DataRequired()])
         submit = SubmitField('Publish')
     ```

     在模板中，渲染这个body字段的方式和其他字段也完全相同，如模板ckeditor.html所示：

     ```html
     {% extends 'base.html' %}
     {% from 'macros.html' import form_field %}
     
     {% block conteng %}
         <h1>Integegrate CKEditor with Flask-CKEditor</h1>
         <form method="post">
             {{ form.csrf_token }}
             {{ form_field(form.title) }}
             {{ form_field(form.body) }}
             {{ form.submit }}
         </form>
     {% endblock %}
     
     {% block scripts %}
         {{ super() }}
         {{ ckeditor.load() }}
         {{ ckeditor.config(name='body') }}
     {% endblock %}
     ```

     

- 单个表单多个提交按钮

  在某些情况下，我们可能需要为一个表单添加多个提交按钮。比如在创建文章的表单中添加发布新文章和保存草稿的按钮。当用户提交表单时，我们需要在视图函数中根据按下的按钮来做出不同的处理。下面的代码中，我们创建了一个这样的表单，其中save表示保存草稿的按钮，publishe表示发布按钮，正文字段使用TextAreaField字段：

  ```python
  class NewPostForm(FlaskForm):
      title = StringField('Title', validators=[DataRequired(), Length(1, 50)])
      body = TextAreaField('Body', validators=[DataRequired()])
      save = SubmitField('Save')
      publish = SubmitField('Publish')
  ```

  当表单数据通过POST请求提交时，Flask会把表单数据解析到request.form字典。**如果表单中有两个提交字段，那么只有被单击的提交字段才会出现在这个字典中。当我们对表单实例或特定的字段属性调用data属性时，WTForms会对数据作进一步处理。对于提交字段的值，它会将其转换为布尔值：被单击的提交字段的值是True，未被单击的值则是False。**

  基于这个机制，我们可以通过提交按钮字段的值来判断当前被单击的按钮，如下：

  ```python
  @app.route('/two-submits', methods=['GET', 'POST'])
  def two_submits():
      form = NewPostForm()
      if form.validate_on_submit():
          if form.save.data:
              flash('You click the Save button.')
          elif form.publish.data:
              flash('You click the publish button.')
          return redirect(url_for('index'))
      return render_template('2submit.html', form=form)
  ```

  在模板2submit.html中渲染这个表单：

  ```html
  {% extends 'base.html' %}
  {% from 'macros.html' import form_field %}
  
  {% block content %}
      <h2>Multiple Submit Buttons</h2>
      <form method="POST">
          {{ form.csrf_token }}
          {{ form_field(form.title) }}
          {{ form_field(form.body) }}
          {{ form.save }}
          {{ form.publish }}
      </form>
  {% endblock %}
  ```

  访问`/two-submits`，当单击某个按钮时，重定向后的页面的提示信息中会包含你单击的按钮名称。

  

- 单个页面多个表单

  除了在单个表单中实现多个按钮提交，有时我们还需要在单个页面上创建多个表单。比如，在程序主页上同时添加登录和注册表单。当在同一个页面上添加多个表单时，我们要解决的一个问题就是在视图函数中判断当前被提交的是哪个表单。

  1. 单视图处理

     创建两个表单，并在模板中分别渲染并不是难事，但是当提交某个表单时，我们就会遇到问题。Flask-WTF根据请求方法判断表单是否提交，但并不判断是哪个表单被提交，所以需要我们手动判断。我们知道被单击的提交字段最终的data属性值是布尔类型，即True或False，而解析后的表单数据使用input字段的name属性值作为键匹配字段数据，也就是说，如果两个表单提交的字段名称都是submit，name我们也无法判断是哪个表单的提交按钮被单击。

     解析问题的第一步就是为两个表单的提交字段设置不同的名称，如下：

     ```python
     class SigninForm(FlaskForm):
         username = StringField('Username', validators=[DataRequired(), Length(1, 20)])
         password = PasswordField('Password', validators=[DataRequired(), Length(8, 128)])
         submit1 = SubmitField('Sign in')
     
     class RegisterForm(FlaskForm):
         username = StringField('Username', validators=[DataRequired(), Length(1, 20)])
         password = PasswordField('Password', validators=[DataRequired(), Length(8, 128)])
         email = StringField('Email', validators=[DataRequired(), Email(), Length(1, 254)])
         submit2 = SubmitField('Register')
     ```

     在视图函数multi_form()中，我们分别实例化这两个表单，根据提交字段的值来区分被提交的表单：

     ```python
     @app.route('/multi-form', methods=['GET', 'POST'])
     def multi_form():
         signin_form = SigninForm()
         register_form = RegisterForm()
     
         if signin_form.submit1.data and signin_form.validate():
             username = signin_form.username.data
             flash('{}, you just submit the signin form.'.format(username))
             return redirect(url_for('index'))
         if register_form.submit2.data and register_form.validate():
             username = register_form.username.data
             flash('{}, you just submit the register form'.format(username))
             return redirect(url_for('index'))
     
         return render_template('2form.html', signin_form=signin_form, register_form=register_form)
     ```

     在视图函数中，我们为两个表单添加了各自的if判断，这两个if语句的内部，我们分别执行搁置的代码逻辑。以登录表单(SigninForm)的if判断为例，如果signin_form.submit1.data的值为True，那就说明用户提交了登录表单，这时我们手动调用signin_form.validate()对这个表单进行验证。

     这两个表单实例通过不同的变量名传入模板，以便在模板中相对渲染对应的表单字段，如下:

     ```html
     {% extends 'base.html' %}
     {% from 'macros.html' import form_field %}
     
     {% block content %}
         <h2>The Register Form</h2>
         <form method="POST">
             {{ register_form.csrf_token }}
             {{ form_field(register_form.username) }}
             {{ form_field(register_form.email) }}
             {{ form_field(register_form.password) }}
             {{ register_form.submit2 }}
         </form>
         <h2>The Signin Form</h2>
         <form method="POST">
             {{ signin_form.csrf_token }}
             {{ form_field(signin_form.username) }}
             {{ form_field(signin_form.password) }}
             {{ signin_form.submit1 }}
         </form>
     {% endblock %}
     ```

     访问`/multi-form`打开页面，当提交某个表单后，会在重定向后的页面的提示消息里看到提交表单的名称。

  2. 多视图处理

     除了通过提交按钮判断，更简洁的方法是通过分离表单的渲染和验证实现。这是表单的提交字段可以使用同一个名称，在视图函数中处理表单时也只需使用我们熟悉的form.validate_on_submit()方法。

     在处理多个表单时，我们可以把表单的渲染在单独的视图函数中处理，如下:

     ```python
     @app.route('/multi-form-multi-view')
     def multi_form_multi_form():
         signin_form = SigninForm2()
         register_form = RegisterForm2()
         return render_template('2form2view.html', signin_form=signin_form, register_form=register_form)
     ```

     这个视图只负责处理GET请求，实例化这两个表单类并渲染模板，另外我们再为每一个表单单独创建一个视图函数来处理验证工作。处理表单提交请求的视图仅监听POST请求，如下：

     ```python
     @app.route('/handle-signin', methods=['POST'])
     def handle_signin():
         signin_form = SigninForm2()
         register_form = RegisterForm2()
         if signin_form.validate_on_submit():
             username = signin_form.username.data
             flash('{}, you just submit the signin form.'.format(username))
             return redirect(url_for('index'))
         return render_template('2form2view.html', signin_form=signin_form, register_form=register_form)
     
     
     @app.route('/handle-register', methods=['POST'])
     def handle_register():
         signin_form = SigninForm2()
         register_form = RegisterForm2()
         if register_form.validate_on_submit():
             username = register_form.username.data
             flash('{}, you just submit the register form.'.format(username))
             return redirect(url_for('index'))
         return render_template('2form2view.html', signin_form=signin_form, register_form=register_form)
     ```

     在HTML中，表单提交请求的目标URL通过action属性设置。为了让表单提交时将请求发送到对应的URL，我们需要设置action属性，如下：

     ```html
     {% block content %}
         <form method="POST" action="{{ url_for('handle_register') }}">
     			...
         </form>
         <form method="POST" action="{{ url_for('handle_signin') }}">
     			...
         </form>
     {% endblock %}
     ```

     虽然现在也可以正常工作，但是这种方法有一个显著的缺点。如果验证未通过，你需要将错误消息的form.errors字段传入模板中。在处理表单的视图中传入表单错误信息，就意味着需要再次渲染模板，但是如果视图函数中还涉及大量要传入模板的变量操作，那么这种方式会带来大量重复。

     对于这个问题，一般的解决方式是通过其他方式传递错误消息，然后统一重定向到渲染表单页面的视图。比如，使用flash()函数迭代form.errors字典发送错误消息（这个字典包含字段名称与错误消息列表的映射），然后重定向到用来渲染表单的multi_form_multi_view视图。下面是一个使用flash()函数来发送表单错误消息的便利函数：

     ```python
     def flash_errors(form):
         for field, errors in form.errors.items():
             for error in errors:
                 flash("Error in the %s field - %s" %(getattr(form, field).label.text, error))
     ```

     

